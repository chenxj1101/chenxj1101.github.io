<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git钩子实现自动部署</title>
      <link href="/2019/12/05/Git%E9%92%A9%E5%AD%90%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/12/05/Git%E9%92%A9%E5%AD%90%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="Git钩子实现自动部署"><a href="#Git钩子实现自动部署" class="headerlink" title="Git钩子实现自动部署"></a>Git钩子实现自动部署</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><p>本地仓库：平时开发所在的环境，可以简单的理解为自己的电脑，记为<strong>L1</strong></p></li><li><p>远程git服务器：<code>git</code>服务所在的服务器，比如我们自己内部搭建的<code>gitlab</code>服务运行在31服务器上，记为<strong>G1</strong> </p></li><li><p>远程仓库： 运行仓库代码运行所在的服务器，比如我们的<code>webserver</code>运行的服务器，记为<strong>R1</strong>  </p></li></ul><p>在这里，我们的<strong>G1</strong>和<strong>R1</strong>恰好是同一台机器</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>假设<strong>G1</strong>上已经有存在的仓库<code>webserver</code>，并且在<strong>L1</strong>和<strong>R1</strong>上都已经有通过<code>git clone</code>命令下载过来的版本一致的代码。并且<strong>R1</strong>上运行<code>&#39;webserver</code>的用户为<code>user1</code>  </p><h4 id="ssh免密登录"><a href="#ssh免密登录" class="headerlink" title="ssh免密登录"></a>ssh免密登录</h4><p>首先要实现运行<code>git</code>服务的用户(<strong>用户git</strong>）和<code>user1</code>的<code>ssh</code> 免密登录。即<code>git</code>可以通过</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ssh</span> user1@xxx.xxx.xxx.xxx <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>直接登录<code>user1</code>  </p><p>在<code>git</code>用户下，运行命令</p><pre class="line-numbers language-bash"><code class="language-bash">ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>会在<code>git</code>的 <code>home</code>目录下生成私钥和公钥文件：</p><pre class="line-numbers language-bash"><code class="language-bash">~/.ssh/id_rsa  <span class="token comment" spellcheck="true">#私钥</span>~/.ssh/id_rsa.pub  <span class="token comment" spellcheck="true">#公钥</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>如果home目录下已经存在密钥文件，则不需要重新生成。否则以前生成的密钥会失效！</strong></p><p>将<code>git</code>用户的公钥添加到<code>user1</code>的<code>~/.ssh/authorized_keys</code>中，即</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> ~/.ssh/id_rsa.pub <span class="token operator">>></span> /home/user1/.ssh/authorized_keys <span class="token comment" spellcheck="true">#权限问题，这个命令不会成功，自己实现相同的结果即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后在<code>user1</code>下修改<code>authorized_keys</code>的权限：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chmod</span> 600 ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再回到<code>git</code>用户下，执行：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">ssh</span> user1@xxx.xxx.xxx.xxx <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不用输入密码，即可直接登录<code>user1</code>用户</p><h4 id="拉取更新脚本"><a href="#拉取更新脚本" class="headerlink" title="拉取更新脚本"></a>拉取更新脚本</h4><p>在<code>user1</code>用户下，新建一个脚本，实现从仓库拉取更新的功能，示例如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>DeployPath<span class="token operator">=</span><span class="token string">"/mnt/analysis/tests/test_uesr1/tmp/webserver"</span>  <span class="token comment" spellcheck="true">#远程仓库路径</span><span class="token function">cd</span> <span class="token variable">$DeployPath</span>IS_BARE<span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">git</span> rev-parse --is-bare-repository<span class="token variable">)</span></span><span class="token keyword">if</span> <span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$IS_BARE</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span><span class="token keyword">echo</span> <span class="token operator">></span><span class="token operator">&amp;</span>2 <span class="token string">"fatal: post-receive: IS_NOT_BARE"</span><span class="token keyword">exit</span> 1<span class="token keyword">fi</span>unset GIT_DIR<span class="token keyword">echo</span> <span class="token string">"=========================="</span><span class="token keyword">echo</span> <span class="token string">"deploying the webserver"</span><span class="token function">git</span> fetch --all  <span class="token comment" spellcheck="true">#使用fetch，不会自动merge</span><span class="token function">git</span> reset --hard origin/master <span class="token comment" spellcheck="true">#强制和远程仓库保持一致</span>time<span class="token operator">=</span><span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span><span class="token keyword">echo</span> <span class="token string">"webserver fetch at time: <span class="token variable">$time</span>."</span><span class="token keyword">echo</span> <span class="token string">"=========================="</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以将此脚本放在<code>&#39;home</code>目录下，命名为<code>git_fetch.sh</code></p><h3 id="钩子的实现"><a href="#钩子的实现" class="headerlink" title="钩子的实现"></a>钩子的实现</h3><p><code>git</code>服务在服务器上会有相应的目录，在该目录下会有所有用户的所有仓库信息。因为我们要实现的是服务端钩子，所以需要在<code>git</code>服务的服务器上设置。</p><p>在我们的<strong>G1</strong>上运行的是<code>gitlab</code>服务，路径为：</p><pre class="line-numbers language-bash"><code class="language-bash"> /var/opt/gitlab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：<code>git</code>用户的<code>home</code>目录也在该路径下</p><p>在该路径下的<code>git-data/repositories</code>目录保存的就是仓库信息。进入我们需要设置钩子的仓库，比如:</p><pre class="line-numbers language-bahs"><code class="language-bahs">/var/opt/gitlab/git-data/repositories/user1/webserver.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在这个目录下，有一个<code>hooks</code>目录，这是一个软连接，里面是全局钩子。这里的钩子修改，所有的仓库都会执行。<br>因为我们只想设置单独的仓库，所以我们需要在当前仓库新建一个<code>custom_hooks</code>的目录，这个名称是写死的，不能用其他名称。<br>在<code>custom_hooks</code>下新建<code>post-receive</code>文件，名称同样是定死的。这个名称的钩子代表<code>push</code>之后执行的动作：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> custom_hooks <span class="token comment" spellcheck="true">#/var/opt/gitlab/git-data/repositories/user1/webserver.git/custom_hooks</span><span class="token function">cd</span> custom_hooksvim post-receive <span class="token comment" spellcheck="true"># 注意是横扛，不是下划线</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>post-receive</code>里写以下命令：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span><span class="token function">ssh</span> user1@xxx.xxx.xxx.xxx  <span class="token string">"sh ~/git_fetch.sh"</span>  <span class="token comment" spellcheck="true">#即登录user1，然后user1执行拉取更新的脚本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>以上新建文件夹和文件的步骤如果是用<code>root</code>或者其他<strong>非git</strong>用户操作的，操作完后需要把所有者改成<code>git</code>：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">chown</span> -R git:git custom_hooks<span class="token function">chmod</span> -R 777 custom_hokks  <span class="token comment" spellcheck="true"># 755应该也可以</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到此钩子的设置就完成了。接下来在本地<strong>L1</strong>修改完代码<code>push</code>到远程仓库后，<strong>R1</strong>上的代码也会自动从远程仓库拉取更新。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>工作流程其实很简单，主要是要分清各个角色执行的功能。</p><ol><li><strong>L1</strong>修改代码，然后push给远程仓库，即<strong>G1</strong></li><li><strong>G1</strong>上的仓库有<code>post-receive</code>钩子，但是执行用户是<code>git</code>。<code>git</code>用户无权限对<code>user1</code>的仓库进行操作，所以通过<code>ssh</code>的方式登录到<code>user1</code>执行拉取更新的操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
            <tag> linux </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="/2019/11/07/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>/2019/11/07/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>决策树</li></ul><p>在现实生活中，我们会遇到各种选择，不论是选择男女朋友，还是挑选水果，都是基于以往的经验来做判断。如果把判断背后的逻辑整理成一个结构图，你会发现它实际上是一个树状图</p><p>决策树建立分为2个阶段：</p><ol><li>构造</li><li>剪枝</li></ol><p><img src="a59abb79f833f4852547e928bdf470a0.png" alt="各种选择"></p><ul><li>根节点：就是树的最顶端，最开始的那个节点。在上图中，“天气”就是一个根节点</li><li>子节点：就是树中间的那些节点，比如说“温度”、“湿度”、“刮风”</li><li>叶节点：就是树最底部的节点，也就是决策结果</li></ul><hr><ul><li>纯度：可以把决策树的构造过程理解成为寻找纯净划分的过程。数学上，我们可以用纯度来表示，纯度换一种方式来解释就是让目标变量的分歧最小</li><li>信息熵：代表了信息的不确定程度。</li><li>信息增益：信息增益指的就是划分可以带来纯度的提高，信息熵的下降。它的计算公式，是父亲节点的信息熵减去所有子节点的信息熵。</li><li>信息增益率：信息增益率 = 信息增益 / 属性熵</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="构造原理"><a href="#构造原理" class="headerlink" title="构造原理"></a>构造原理</h3><p>ID3 算法选择信息增益最大的节点作为父节点，剩下的点作为子节点。再对子节点的信息增益进行计算，同样选择信息增益大的优先</p><h3 id="剪枝原理"><a href="#剪枝原理" class="headerlink" title="剪枝原理"></a>剪枝原理</h3><p>剪枝就是给决策树瘦身，这一步想实现的目标就是，不需要太多的判断，同样可以得到不错的结果。</p><ul><li>预剪枝：<br>预剪枝是在决策树构造时就进行剪枝。方法是在构造的过程中对节点进行评估，如果对某个节点进行划分，在验证集中不能带来准确性的提升，那么对这个节点进行划分就没有意义，这时就会把当前节点作为叶节点，不对其进行划分。</li></ul><ul><li>后剪枝：<br>后剪枝就是在生成决策树之后再进行剪枝，通常会从决策树的叶节点开始，逐层向上对每个节点进行评估。如果剪掉这个节点子树，与保留该节点子树在分类准确性上差别不大，或者剪掉该节点子树，能在验证集中带来准确性的提升，那么就可以把该节点子树进行剪枝。方法是：用这个节点子树的叶子节点来替代该节点，类标记为这个节点子树中最频繁的那个类</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>信息熵公式：</p><p><img src="e02b07d804b6f631f7192f901fc00bf4.png" alt="信息熵公式"></p><p><strong>信息熵越大，纯度越低</strong></p><blockquote><p>我们在构造决策树的时候，会基于纯度来构建。而经典的 “不纯度”的指标有三种，分别是信息增益（ID3 算法）、信息增益率（C4.5 算法）以及基尼指数（Cart 算法）。</p></blockquote><h3 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a>ID3算法</h3><p>ID3 算法计算的是信息增益，信息增益指的就是划分可以带来纯度的提高，信息熵的下降。<br>它的计算公式，是父亲节点的信息熵减去所有子节点的信息熵。</p><p>信息增益公式：<br><img src="4599c229c6323e9ec4a415bab302e531.png" alt="信息增益公式"></p><blockquote><p>ID3 有一个缺陷就是，有些属性可能对分类任务没有太大作用，但是他们仍然可能会被选为最优属性。这种缺陷不是每次都会发生，只是存在一定的概率。在大部分情况下，ID3 都能生成不错的决策树分类。</p></blockquote><h3 id="C4-5算法"><a href="#C4-5算法" class="headerlink" title="C4.5算法"></a>C4.5算法</h3><h4 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h4><p>因为 ID3 在计算的时候，倾向于选择取值多的属性。为了避免这个问题，C4.5 采用信息增益率的方式来选择属性。信息增益率 = 信息增益 / 属性熵</p><h4 id="悲观剪枝"><a href="#悲观剪枝" class="headerlink" title="悲观剪枝"></a>悲观剪枝</h4><p>ID3 构造决策树的时候，容易产生过拟合的情况。在 C4.5 中，会在决策树构造之后采用悲观剪枝，这样可以提升决策树的泛化能力。<br>悲观剪枝是后剪枝技术中的一种，通过递归估算每个内部节点的分类错误率，比较剪枝前后这个节点的分类错误率来决定是否对其进行剪枝。这种剪枝方法不再需要一个单独的测试数据集。</p><h4 id="离散化处理连续属性"><a href="#离散化处理连续属性" class="headerlink" title="离散化处理连续属性"></a>离散化处理连续属性</h4><p>C4.5 可以处理连续属性的情况，对连续的属性进行离散化的处理。比如打篮球存在的“湿度”属性，不按照“高、中”划分，而是按照湿度值进行计算，那么湿度取什么值都有可能。该怎么选择这个阈值呢，C4.5 选择具有最高信息增益的划分所对应的阈值。</p><h4 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h4><p><img src="bd3105be01b0593a9dc140a5f721481e.png" alt="处理缺失值"></p><h3 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h3><h4 id="CART分类树"><a href="#CART分类树" class="headerlink" title="CART分类树"></a>CART分类树</h4><p>CART 分类树与 C4.5 算法类似，只是属性选择的指标采用的是基尼系数。<br>基尼系数公式：<br><img src="70a369441c108b6f2a684894b7f3b4c6.png" alt="基尼系数公式"></p><p><img src="cfc6f0b55d587d22ec921d6b3d2b4bd6.png" alt="例子"></p><p>节点 D 的基尼系数等于子节点 D1 和 D2 的归一化基尼系数之和，用公式表示为：<br><img src="35344b789cabfbe5bb215db08111140a.png" alt="归一化之和"></p><p><img src="57f79a44be7864216b48d3669e148e4f.png" alt="归一化之和"></p><p>节点 D 被属性 A 划分后的基尼系数越大，样本集合的不确定性越大，也就是不纯度越高。</p><p>代码实例</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeClassifier<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_iris<span class="token comment" spellcheck="true"># 准备数据集</span>iris<span class="token operator">=</span>load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取特征集和分类标识</span>features <span class="token operator">=</span> iris<span class="token punctuation">.</span>datalabels <span class="token operator">=</span> iris<span class="token punctuation">.</span>target<span class="token comment" spellcheck="true"># 随机抽取33%的数据作为测试集，其余为训练集</span>train_features<span class="token punctuation">,</span> test_features<span class="token punctuation">,</span> train_labels<span class="token punctuation">,</span> test_labels <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>features<span class="token punctuation">,</span> labels<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.33</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建CART分类树</span>clf <span class="token operator">=</span> DecisionTreeClassifier<span class="token punctuation">(</span>criterion<span class="token operator">=</span><span class="token string">'gini'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 拟合构造CART分类树</span>clf <span class="token operator">=</span> clf<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_features<span class="token punctuation">,</span> train_labels<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 用CART分类树做预测</span>test_predict <span class="token operator">=</span> clf<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_features<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 预测结果与测试集结果作比对</span>score <span class="token operator">=</span> accuracy_score<span class="token punctuation">(</span>test_labels<span class="token punctuation">,</span> test_predict<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"CART分类树准确率 %.4lf"</span> <span class="token operator">%</span> score<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CART回归树"><a href="#CART回归树" class="headerlink" title="CART回归树"></a>CART回归树</h4><p>在 CART 分类树中采用的是基尼系数作为标准，而在 CART 回归树中，根据样本的混乱程度，也就是样本的离散程度来评价<strong>不纯度</strong></p><p>离散程度有2种表示方法：</p><ul><li>差值的绝对值</li><li>方差</li></ul><p>两种方法分别对应2中不同的目标函数最优化的标准：</p><ul><li>最小绝对值偏差（LAD）</li><li>最小二乘偏差（LSD）</li></ul><p>通常使用最小二乘偏差的情况更常见一些</p><p>代码实例</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> mean_squared_error<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> train_test_split<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_boston<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> r2_score<span class="token punctuation">,</span>mean_absolute_error<span class="token punctuation">,</span>mean_squared_error<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeRegressor<span class="token comment" spellcheck="true"># 准备数据集</span>boston<span class="token operator">=</span>load_boston<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 探索数据</span><span class="token keyword">print</span><span class="token punctuation">(</span>boston<span class="token punctuation">.</span>feature_names<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 获取特征集和房价</span>features <span class="token operator">=</span> boston<span class="token punctuation">.</span>dataprices <span class="token operator">=</span> boston<span class="token punctuation">.</span>target<span class="token comment" spellcheck="true"># 随机抽取33%的数据作为测试集，其余为训练集</span>train_features<span class="token punctuation">,</span> test_features<span class="token punctuation">,</span> train_price<span class="token punctuation">,</span> test_price <span class="token operator">=</span> train_test_split<span class="token punctuation">(</span>features<span class="token punctuation">,</span> prices<span class="token punctuation">,</span> test_size<span class="token operator">=</span><span class="token number">0.33</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建CART回归树</span>dtr<span class="token operator">=</span>DecisionTreeRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 拟合构造CART回归树</span>dtr<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>train_features<span class="token punctuation">,</span> train_price<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 预测测试集中的房价</span>predict_price <span class="token operator">=</span> dtr<span class="token punctuation">.</span>predict<span class="token punctuation">(</span>test_features<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 测试集的结果评价</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'回归树二乘偏差均值:'</span><span class="token punctuation">,</span> mean_squared_error<span class="token punctuation">(</span>test_price<span class="token punctuation">,</span> predict_price<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'回归树绝对值偏差均值:'</span><span class="token punctuation">,</span> mean_absolute_error<span class="token punctuation">(</span>test_price<span class="token punctuation">,</span> predict_price<span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CCP剪枝"><a href="#CCP剪枝" class="headerlink" title="CCP剪枝"></a>CCP剪枝</h4><p>CART 决策树的剪枝主要采用的是 CCP 方法，它是一种后剪枝的方法，英文全称叫做 cost-complexity prune，中文叫做代价复杂度。</p><p>这种剪枝方式用到一个指标叫做节点的表面误差率增益值，以此作为剪枝前后误差的定义。用公式表示则是：<br><img src="5317f040438cea216820c1dc86df4292.png" alt="CCP剪枝"></p><p>其中 Tt 代表以 t 为根节点的子树，C(Tt) 表示节点 t 的子树没被裁剪时子树 Tt 的误差，C(t) 表示节点 t 的子树被剪枝后节点 t 的误差，|Tt|代子树 Tt 的叶子数，剪枝后，T 的叶子数减少了|Tt|-1</p><p>所以节点的表面误差率增益值等于节点 t 的子树被剪枝后的误差变化除以剪掉的叶子数量。</p><p>因为我们希望剪枝前后误差最小，所以我们要寻找的就是最小α值对应的节点，把它剪掉。这时候生成了第一个子树。重复上面的过程，继续剪枝，直到最后只剩下根节点，即为最后一个子树。</p><h4 id="CART总结"><a href="#CART总结" class="headerlink" title="CART总结"></a>CART总结</h4><p>作为分类树，CART 采用基尼系数作为节点划分的依据，得到的是离散的结果，也就是分类结果；<br>作为回归树，CART 可以采用最小绝对偏差（LAD），或者最小二乘偏差（LSD）作为节点划分的依据，得到的是连续值，即回归预测结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ID3 算法的优点是方法简单，缺点是对噪声敏感。训练数据如果有少量错误，可能会产生决策树分类错误。<br>C4.5 在 ID3 的基础上，用信息增益率代替了信息增益，解决了噪声敏感的问题，并且可以对构造树进行剪枝、处理连续数值以及数值缺失等情况，但是由于 C4.5 需要对数据集进行多次扫描，算法效率相对较低。</p><ul><li>ID3 算法，基于信息增益做判断；</li><li>C4.5 算法，基于信息增益率做判断；</li><li>CART 算法，分类树是基于基尼系数做判断。回归树是基于偏差做判断。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CART </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 决策树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python操作xlsx文件的包openpyxl</title>
      <link href="/2019/09/26/python%E6%93%8D%E4%BD%9Cxlsx%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85openpyxl/"/>
      <url>/2019/09/26/python%E6%93%8D%E4%BD%9Cxlsx%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%85openpyxl/</url>
      
        <content type="html"><![CDATA[<p>Python扩展库openpyxl，可以操作07版以上的xlsx文件。可以创建工作簿、选择活动工作表、写入单元格数据，设置单元格字体颜色、边框样式，合并单元格，设置单元格背景等等。</p><p>需要增加可以颜色进入包安装目录的</p><blockquote><p>your_pthon_path/site-packages/openpyxl/styles  </p></blockquote><p>修改colors.py文件下的</p><pre><code>COLOR_INDEX = (    &#39;00000000&#39;, &#39;00FFFFFF&#39;, &#39;00FF0000&#39;, &#39;0000FF00&#39;, &#39;000000FF&#39;, #0-4    &#39;00FFFF00&#39;, &#39;00FF00FF&#39;, &#39;0000FFFF&#39;, &#39;00000000&#39;, &#39;00FFFFFF&#39;, #5-9    &#39;00FF0000&#39;, &#39;0000FF00&#39;, &#39;000000FF&#39;, &#39;00FFFF00&#39;, &#39;00FF00FF&#39;, #10-14    &#39;0000FFFF&#39;, &#39;00800000&#39;, &#39;00008000&#39;, &#39;00000080&#39;, &#39;00808000&#39;, #15-19    &#39;00800080&#39;, &#39;00008080&#39;, &#39;00C0C0C0&#39;, &#39;00808080&#39;, &#39;009999FF&#39;, #20-24    &#39;00993366&#39;, &#39;00FFFFCC&#39;, &#39;00CCFFFF&#39;, &#39;00660066&#39;, &#39;00FF8080&#39;, #25-29    &#39;000066CC&#39;, &#39;00CCCCFF&#39;, &#39;00000080&#39;, &#39;00FF00FF&#39;, &#39;00FFFF00&#39;, #30-34    &#39;0000FFFF&#39;, &#39;00800080&#39;, &#39;00800000&#39;, &#39;00008080&#39;, &#39;000000FF&#39;, #35-39    &#39;0000CCFF&#39;, &#39;00CCFFFF&#39;, &#39;00CCFFCC&#39;, &#39;00FFFF99&#39;, &#39;0099CCFF&#39;, #40-44    &#39;00FF99CC&#39;, &#39;00CC99FF&#39;, &#39;00FFCC99&#39;, &#39;003366FF&#39;, &#39;0033CCCC&#39;, #45-49    &#39;0099CC00&#39;, &#39;00FFCC00&#39;, &#39;00FF9900&#39;, &#39;00FF6600&#39;, &#39;00666699&#39;, #50-54    &#39;00969696&#39;, &#39;00003366&#39;, &#39;00339966&#39;, &#39;00003300&#39;, &#39;00333300&#39;, #55-59    &#39;00993300&#39;, &#39;00993366&#39;, &#39;00333399&#39;, &#39;00333333&#39;, &#39;System Foreground&#39;, &#39;System Background&#39; #60-64    &#39;00D2B48C&#39;, &#39;0087CEFA&#39;, &#39;0000BFFF&#39; #自己添加的)</code></pre><p>以00+16进制RGB颜色代码的形式即可</p><p>自己写的一个生成xlsx文件的代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true">#-*- coding: utf-8 -*-</span><span class="token keyword">import</span> openpyxl<span class="token keyword">from</span> openpyxl <span class="token keyword">import</span> Workbook<span class="token keyword">from</span> openpyxl<span class="token punctuation">.</span>styles <span class="token keyword">import</span> colors<span class="token punctuation">,</span>Font<span class="token punctuation">,</span>Border<span class="token punctuation">,</span>Side<span class="token punctuation">,</span>PatternFill<span class="token punctuation">,</span>Alignmentwb <span class="token operator">=</span> Workbook<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">#创建工作簿</span>ws <span class="token operator">=</span> wb<span class="token punctuation">.</span>active       <span class="token comment" spellcheck="true">#激活工作簿</span>ws<span class="token punctuation">.</span>merge_cells<span class="token punctuation">(</span><span class="token string">'C3:E3'</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#合并单元格</span>ws<span class="token punctuation">.</span>merge_cells<span class="token punctuation">(</span><span class="token string">'C4:E4'</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span>merge_cells<span class="token punctuation">(</span><span class="token string">'C20:I20'</span><span class="token punctuation">)</span>ws<span class="token punctuation">.</span>merge_cells<span class="token punctuation">(</span><span class="token string">'C21:I21'</span><span class="token punctuation">)</span>left<span class="token punctuation">,</span> right<span class="token punctuation">,</span> top<span class="token punctuation">,</span> bottom <span class="token operator">=</span> <span class="token punctuation">[</span>Side<span class="token punctuation">(</span>style<span class="token operator">=</span><span class="token string">'thin'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'000000'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">4</span>  <span class="token comment" spellcheck="true">#设置单元格边框属性</span>border <span class="token operator">=</span> Border<span class="token punctuation">(</span>left<span class="token operator">=</span>left<span class="token punctuation">,</span> right<span class="token operator">=</span>right<span class="token punctuation">,</span> top<span class="token operator">=</span>top<span class="token punctuation">,</span> bottom<span class="token operator">=</span>bottom<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">#设置单元格边框格式</span>fill1 <span class="token operator">=</span> PatternFill<span class="token punctuation">(</span>start_color <span class="token operator">=</span> <span class="token string">'FFFF00'</span><span class="token punctuation">,</span> end_color <span class="token operator">=</span> <span class="token string">'FFFF00'</span><span class="token punctuation">,</span> fill_type <span class="token operator">=</span> <span class="token string">'solid'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#设置单元格背景色</span>fill2 <span class="token operator">=</span> PatternFill<span class="token punctuation">(</span>start_color <span class="token operator">=</span> <span class="token string">'D2B48C'</span><span class="token punctuation">,</span> end_color <span class="token operator">=</span> <span class="token string">'D2B48C'</span><span class="token punctuation">,</span> fill_type <span class="token operator">=</span> <span class="token string">'solid'</span><span class="token punctuation">)</span>fill3 <span class="token operator">=</span> PatternFill<span class="token punctuation">(</span>start_color <span class="token operator">=</span> <span class="token string">'00BFFF'</span><span class="token punctuation">,</span> end_color <span class="token operator">=</span> <span class="token string">'00BFFF'</span><span class="token punctuation">,</span> fill_type <span class="token operator">=</span> <span class="token string">'solid'</span><span class="token punctuation">)</span>fill4 <span class="token operator">=</span> PatternFill<span class="token punctuation">(</span>start_color <span class="token operator">=</span> <span class="token string">'FF0000'</span><span class="token punctuation">,</span> end_color <span class="token operator">=</span> <span class="token string">'FF0000'</span><span class="token punctuation">,</span> fill_type <span class="token operator">=</span> <span class="token string">'solid'</span><span class="token punctuation">)</span>align1 <span class="token operator">=</span> Alignment<span class="token punctuation">(</span>horizontal<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">,</span> vertical<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#设置文本对齐</span>align2 <span class="token operator">=</span> Alignment<span class="token punctuation">(</span>horizontal<span class="token operator">=</span><span class="token string">'left'</span><span class="token punctuation">,</span> vertical<span class="token operator">=</span><span class="token string">'center'</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'CDEFGHIJK'</span><span class="token punctuation">:</span>        ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>border <span class="token operator">=</span> border <span class="token comment" spellcheck="true">#给每个单元格设置相应的格式     </span>        <span class="token comment" spellcheck="true">#ws[col+str(3)].fill = fill1</span>        <span class="token comment" spellcheck="true">#ws[col+str(i)].alignment = align</span><span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'CDEFGHIJK'</span><span class="token punctuation">:</span>    ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fill <span class="token operator">=</span> fill1    ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fill <span class="token operator">=</span> fill3    ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fill <span class="token operator">=</span> fill4    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fill <span class="token operator">=</span> fill2<span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'CDEFGHIJK'</span><span class="token punctuation">:</span>    ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>alignment <span class="token operator">=</span> align1<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'CDE'</span><span class="token punctuation">:</span>        ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>alignment <span class="token operator">=</span> align2<span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'CDEFGHIJK'</span><span class="token punctuation">:</span>    ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'test1'</span>  <span class="token comment" spellcheck="true">#单元格赋值</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'CDE'</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">and</span> col <span class="token operator">==</span> <span class="token string">'C'</span><span class="token punctuation">:</span>            <span class="token keyword">pass</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'test2'</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'EFGHIJK'</span><span class="token punctuation">:</span>        ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">50</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> col <span class="token keyword">in</span> <span class="token string">'JK'</span><span class="token punctuation">:</span>        ws<span class="token punctuation">[</span>col<span class="token operator">+</span>str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span>wb<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'test.xlsx'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#保存文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单元格字体等也可以使用相应的模块去设置，具体可以见<a href="https://openpyxl.readthedocs.io/en/stable/" target="_blank" rel="noopener">官方说明文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> excel </tag>
            
            <tag> openpyxl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsftpd安装配置说明</title>
      <link href="/2019/08/29/vsftpd%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/08/29/vsftpd%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p><code>vsftpd</code>是在<code>linux</code>环境下，使用最多的<code>FTP</code>服务端软件。</p><p><code>vsftpd</code>默认只能使用root用户运行。使用非<code>root</code>用户运行，需要在配置文件里设置<code>run_as_launching_user=YES</code>。</p><p><strong>官方强烈不推荐使用这种方式启动，会带来巨大的安全问题，并且会导致无法使用<code>chroot</code>技术来限制文件访问。</strong></p><p>以下安装配置均在<code>root</code>账号下进行。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class="line-numbers language-bash"><code class="language-bash">yum <span class="token function">install</span> -y vsftpdyum <span class="token function">install</span> -y db4 <span class="token comment" spellcheck="true">#设置虚拟账户的本地数据库文件用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>也可以下载源码安装，解压之后直接<code>make &amp; make install</code>即可安装。<br>不提供<code>configure</code>文件，所以无法指定路径。</p><p>安装完成后会在相关目录生成文件，需要用到的如下：</p><pre class="line-numbers language-bash"><code class="language-bash">/usr/sbin/vsftpd <span class="token comment" spellcheck="true">#vsftpd可执行文件</span>/etc/vsftpd/vsftpd.conf <span class="token comment" spellcheck="true">#主配置文件</span>/etc/pam.d/vsftpd <span class="token comment" spellcheck="true">#PAM认证文件</span>/etc/vsftpd.ftpusers <span class="token comment" spellcheck="true">#禁用使用VSFTPD的用户列表文件</span>/etc/vsftpd.user_list <span class="token comment" spellcheck="true">#禁止或允许使用VSFTPD的用户列表文件</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="vsftpd主要配置"><a href="#vsftpd主要配置" class="headerlink" title="vsftpd主要配置"></a>vsftpd主要配置</h3><p>先对默认配置文件进行备份，再进行配置。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cp</span> /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>配置文件具体配置如下：</p><pre class="line-numbers language-bash"><code class="language-bash">anonymous_enable<span class="token operator">=</span>NO <span class="token comment" spellcheck="true">#不允许匿名登录</span>local_enable<span class="token operator">=</span>YESwrite_enable<span class="token operator">=</span>YESlocal_umask<span class="token operator">=</span>022  <span class="token comment" spellcheck="true">#上传文件权限补码，最终上传后的文件权限为  666-022=644</span>dirmessage_enable<span class="token operator">=</span>YESxferlog_enable<span class="token operator">=</span>YESconnect_from_port_20<span class="token operator">=</span>YESxferlog_std_format<span class="token operator">=</span>YESascii_upload_enable<span class="token operator">=</span>YESascii_download_enable<span class="token operator">=</span>YESchroot_local_user<span class="token operator">=</span>NO <span class="token comment" spellcheck="true">#虚拟账户配置下，在下面两个chroot配置后，这个参数必须为NO，否则登陆FTP后还可以访问其他目录！</span>chroot_list_enable<span class="token operator">=</span>YES allow_writeable_chroot<span class="token operator">=</span>YESchroot_list_file<span class="token operator">=</span>/home/ftp/config/chroot_list <span class="token comment" spellcheck="true">#指定不能离开家目录的用户列表文件，一行一个用户。使用此方法时必须chroot_local_user=NO。说明这个列表里面的用户登陆ftp后都只能访问其主目录，其他目录都不能访问！</span>listen<span class="token operator">=</span>YES <span class="token comment" spellcheck="true">#监听IPV4</span>listen_ipv6<span class="token operator">=</span>NO <span class="token comment" spellcheck="true">#监听IPV6，不能和上面的listen同时设置为YES</span>pam_service_name<span class="token operator">=</span>vsftpd <span class="token comment" spellcheck="true">#指定PAM配置文件，即下面的/etc/pam.d/vsftpd文件要和这里指定的一致</span>userlist_enable<span class="token operator">=</span>YEStcp_wrappers<span class="token operator">=</span>YESvirtual_use_local_privs<span class="token operator">=</span>YESguest_enable<span class="token operator">=</span>YES <span class="token comment" spellcheck="true">#启用虚拟账户</span>guest_username<span class="token operator">=</span>chenxj <span class="token comment" spellcheck="true">#将虚拟用户映射为本地chenxj用户（前提是local_enable=YES），更安全的做法是映射为nobody用户，因为nobody的权限最低</span>user_config_dir<span class="token operator">=</span>/home/ftp/config/vuser_conf <span class="token comment" spellcheck="true">#指定不同虚拟用户配置文件的存放路径</span>listen_port<span class="token operator">=</span>21 <span class="token comment" spellcheck="true">#监听的ftp端口，改成其他端口，会导致无法启动</span>pasv_min_port<span class="token operator">=</span>40001 <span class="token comment" spellcheck="true">#分配给ftp账号的最小端口。被动模式下的配置</span>pasv_max_port<span class="token operator">=</span>40100 <span class="token comment" spellcheck="true">#分配给ftp账号的最大端口。每个账号分配一个端口，即最大允许100个ftp账号连接</span>max_clients<span class="token operator">=</span>150 <span class="token comment" spellcheck="true">#客户端的最大连接数</span>accept_timeout<span class="token operator">=</span>5connect_timeout<span class="token operator">=</span>1max_per_ip<span class="token operator">=</span>5 <span class="token comment" spellcheck="true">#每个ip最大连接数</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以上配置有修改，需要重启vsftpd服务才能生效</strong>。</p><h3 id="虚拟账户设置"><a href="#虚拟账户设置" class="headerlink" title="虚拟账户设置"></a>虚拟账户设置</h3><p>在自己决定的目录（如：<code>/home/ftp/config</code>）新建<code>vuser_passwd.txt</code>，奇数行为账号，偶数行为密码:</p><pre class="line-numbers language-bash"><code class="language-bash">user1  <span class="token comment" spellcheck="true">#账号1</span>user1@2018 <span class="token comment" spellcheck="true">#账号1密码</span>user2 <span class="token comment" spellcheck="true">#账号2</span>user2@2018 <span class="token comment" spellcheck="true">#账号2密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在此目录下，生成虚拟用户口令认证的db文件，这是本地数据库文件：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cd</span> /home/ftp/configdb_load -T -t <span class="token function">hash</span> -f vuser_passwd.txt vuser_passwd.db<span class="token function">chmod</span> 600 vuser_passwd.db <span class="token comment" spellcheck="true">#安全起见，将该文件的权限设置为root读写</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>同时在该目录下，新建<code>chroot_list</code>文件，即<code>/etc/vsftpd/vsftpd.conf</code>中的<code>chroot_list_file=</code>，并将虚拟账户的账号放在这个文件中。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> chroot_listuser1user2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后新建<code>vuser_conf</code>目录，即<code>/etc/vsftpd/vsftpd.conf</code>中的<code>user_config_dir=</code>。用于存放每个虚拟账户的配置文件，虚拟账户的配置文件以虚拟账户的用户名命名。</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">mkdir</span> vuser_confvim user1<span class="token comment" spellcheck="true"># 配置如下：</span>local_root<span class="token operator">=</span>/home/ftp/data/user1 <span class="token comment" spellcheck="true">#目录需已经存在，拥有者需为/etc/vsftpd/vsftpd.conf 中guest_username指定的用户</span>write_enable<span class="token operator">=</span>YESanon_umask<span class="token operator">=</span>022anon_world_readable_only<span class="token operator">=</span>NOanon_upload_enable<span class="token operator">=</span>YESanon_mkdir_write_enable<span class="token operator">=</span>YESanon_other_write_enable<span class="token operator">=</span>YES<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以上配置有修改，不需要重启vsftpd，即时生效</strong>。</p><h3 id="PAM认证"><a href="#PAM认证" class="headerlink" title="PAM认证"></a>PAM认证</h3><p>修改<code>/etc/pam.d/vsftpd</code>文件，注释掉原来的内容，在最后两行添加认证文件路径，如下所示：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#%PAM-1.0</span><span class="token comment" spellcheck="true">#session    optional     pam_keyinit.so    force revoke</span><span class="token comment" spellcheck="true">#auth       required    pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed</span><span class="token comment" spellcheck="true">#auth       required    pam_shells.so</span><span class="token comment" spellcheck="true">#auth       include    password-auth</span><span class="token comment" spellcheck="true">#account    include    password-auth</span><span class="token comment" spellcheck="true">#session    required     pam_loginuid.so</span><span class="token comment" spellcheck="true">#session    include    password-auth</span>auth    required    /lib64/security/pam_userdb.so    db<span class="token operator">=</span>/home/ftp/config/vuser_passwdaccount required    /lib64/security/pam_userdb.so db<span class="token operator">=</span>/home/ftp/config/vuser_passwd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>中间使用<code>Tab</code>键分隔。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><pre class="line-numbers language-bash"><code class="language-bash">systemctl start vsftpd <span class="token comment" spellcheck="true">#启动</span>systemctl restart vsftpd <span class="token comment" spellcheck="true">#重启</span>systemctl stop vsftpd <span class="token comment" spellcheck="true">#停止</span>systemctl status vsftpd <span class="token comment" spellcheck="true">#查看状态</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>写了<code>3</code>个小脚本来管理。</p><h3 id="新增用户"><a href="#新增用户" class="headerlink" title="新增用户"></a>新增用户</h3><pre class="line-numbers language-bash"><code class="language-bash">sh /home/ftp/script/setFTP.sh <span class="token operator">&lt;</span>user<span class="token operator">></span> <span class="token operator">&lt;</span>passwd<span class="token operator">></span> <span class="token operator">&lt;</span>path<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>代码如下：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>user<span class="token operator">=</span><span class="token variable">$1</span>passwd<span class="token operator">=</span><span class="token variable">$2</span>path<span class="token operator">=</span><span class="token variable">$3</span><span class="token keyword">echo</span> <span class="token variable">$user</span> <span class="token operator">>></span> /home/ftp/config/chroot_list<span class="token keyword">echo</span> -e <span class="token string">"<span class="token variable">$user</span>\n<span class="token variable">$passwd</span>"</span> <span class="token operator">>></span> /home/ftp/config/vuser_passwd.txtdb_load -T -t <span class="token function">hash</span> -f /home/ftp/config/vuser_passwd.txt /home/ftp/config/vuser_passwd.db<span class="token function">mkdir</span> <span class="token variable">$path</span><span class="token function">chown</span> -R chenxj:chenxj <span class="token variable">$path</span><span class="token function">chmod</span> 700 <span class="token variable">$path</span><span class="token keyword">echo</span> -e <span class="token string">"local_root=<span class="token variable">$path</span>\nwrite_enable=YES\nanon_world_readable_only=NO\nanon_upload_enable=YES\nanon_mkdir_write_enable=YES\nanon_other_write_enable=YES"</span> <span class="token operator">></span> /home/ftp/config/vuser_conf/<span class="token variable">$user</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="取消和恢复"><a href="#取消和恢复" class="headerlink" title="取消和恢复"></a>取消和恢复</h3><p>如果希望某个路径关闭FTP，则直接修改其权限为<code>600</code>即可，则在配置文件中<code>local_root</code>指定为该路径的账号全都无法登陆。同理，恢复则将权限修改为<code>700</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">sh /home/ftp/script/cancelFTP.sh <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token comment" spellcheck="true">#chmod 600 $path</span>sh /home/ftp/script/recoverFTP.sh <span class="token operator">&lt;</span>path<span class="token operator">></span> <span class="token comment" spellcheck="true">#chmod 700 $path</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> ftp </tag>
            
            <tag> vsftpd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UMI简介</title>
      <link href="/2019/07/28/UMI%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/07/28/UMI%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="UMI是什么"><a href="#UMI是什么" class="headerlink" title="UMI是什么"></a>UMI是什么</h2><p><strong>UMI</strong>全称：<em>Unique Molecular Identifiers</em>。<br>又称分子条形码技术，是对原始样本基因组打断后的每一个片段都加上一段特有的标签序列，用于区分同一样本中成千上万的不同的片段，在后续的数据分析中可以通过这些标签序列来排除由于 <strong>DNA</strong> 聚合酶和扩增以及测序过程中所引入的错误。分子条形码通常由大约 <code>10nt</code> 左右的随机序列（比如 NNNNNNN)，或者简并碱基（NNNRNYN）组成。<br>有别于样品标签（<code>sample index</code> 或 <code>sample barcode</code>），分子条形码是针对同一个样本中的不同片段加上的标签序列，而样品标签是用于区分不同样本而加上的标签序列。<br>因此，每一个样本只能有一个相同的样品标签，但可以有成千上万的分子条形码。</p><p><strong>UMI是给同一个样本的不同片段打上标签</strong></p><h2 id="UMI加在哪里？"><a href="#UMI加在哪里？" class="headerlink" title="UMI加在哪里？"></a>UMI加在哪里？</h2><p>双端<code>index</code>，如果一端的<code>index</code>已经可以区分不同的样本。则另一端<code>index</code>的位置上可以用<code>UMI</code>来代替。即<code>UMI</code>在<code>index</code>的位置上。<code>UMI</code>的长度与<code>index</code>相同。</p><p><code>UMI</code>也可以加在插入片段中，在<code>index</code>和<code>UMI</code>之间可能需要连接酶链接。在我们的某个项目中，<code>UMI</code>就是加在插入片段中，<code>index</code>和<code>UMI</code>之间有<code>8bp</code>的酶切位点。</p><h2 id="UMI如何处理？"><a href="#UMI如何处理？" class="headerlink" title="UMI如何处理？"></a>UMI如何处理？</h2><p>使用<code>fastp</code>和<code>gencore</code>软件可以很方便的处理<code>UMI</code>。</p><h3 id="标记UMI"><a href="#标记UMI" class="headerlink" title="标记UMI"></a>标记UMI</h3><p>使用<code>fastp</code>标记<code>reads</code>上的<code>UMI</code>序列</p><pre class="line-numbers language-bash"><code class="language-bash">fastp -i R1.fq -o out.R1.fq -U --umi_loc<span class="token operator">=</span>read1 --umi_len<span class="token operator">=</span>8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>--umi_loc</code>指定<code>UMI</code>的位置，如果是在<code>reads</code>上，则还需要指定<code>UMI</code>的长度。</p><p><a href="https://github.com/OpenGene/fastp" target="_blank" rel="noopener">FASTP用法</a></p><h3 id="得到一致性序列"><a href="#得到一致性序列" class="headerlink" title="得到一致性序列"></a>得到一致性序列</h3><p>使用<code>gencore</code>的可以得到一致性序列</p><pre class="line-numbers language-bash"><code class="language-bash">gencore -i in.bam -o out.bam -r hg19.fa -s 3 --umi_prefix<span class="token operator">=</span>UMI --ratio_threshold<span class="token operator">=</span>0.9 <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
            <tag> UMI </tag>
            
            <tag> NGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重复序列注释软件REPET</title>
      <link href="/2018/10/15/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6REPET/"/>
      <url>/2018/10/15/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E6%B3%A8%E9%87%8A%E8%BD%AF%E4%BB%B6REPET/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REPET是一个寻找基因组中的重复序列并进行注释和分析的软件。主要分为两个部分  </p><ol><li>TEdenovo</li><li>TEannot</li></ol><p><strong>TEdenovo</strong>部分是通过denovo的方式找寻重复序列<br>首先使用BLASTER对基因组进行自身比对<br>使用RECON、GROUPER、PILER这3个软件进行聚类，并匹配寻找散在重复<br>对每一个聚类结果进行多序列比对得到一致性序列<br>最后根据TEs的特征对一致性序列进行分类，并去除冗余序列，得到一个TE sequences的库<br><img src="https://urgi.versailles.inra.fr/var/storage/images/media/images/te_denovo/8252-4-eng-GB/TE_DeNovo.png" alt="TEdenovo">  </p><p><strong>TEannot</strong>部分是konowledge based的方式找寻重复序列<br>首先是使用BLASTER、RepeatMasker、CENSOR寻找基因组中的重复序列（库文件可以是TEdenovo产生的，也可以是其他的）<br>然后根据经验值对假阳性匹配进行过滤<br>通过TRF、RepeatMasker、MREPS寻找并注释基因组中的SSR<br>使用MATCHER将属于同一个TE的片段链接起来<br>最后将注释以GFF3或gameXML的形式输出  </p><p><img src="https://urgi.versailles.inra.fr/var/storage/images/media/images/te_annot/8256-3-eng-GB/TE_Annot.png" alt="TEannot">  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>首先请先创建项目目录，然后将基因组文件（fa格式）链接或复制到目录。<br>因为REPET的任务信息以及某些数据是通过Mysql操作的，所以事先需要有Mysql的账号，以及一个能使用的库。然后请以以下格式保存  </p><blockquote><p>mysql_user<br>mysql_pawd<br>datebase</p></blockquote><p>项目目录里两个文件齐全后，请运行以下脚本，会自动生成REPET所需要的配置文件以及接下来需要运行的任务脚本  </p><pre><code>python /p299/user/og06/chenxiangjian1609/software/REPET/ready.py -i test.fa -p project -g 55 -d db.cfg</code></pre><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>-i 表示输入文件，需要是fa格式的<br>-p 表示项目名称，REPET要求fa文件要与项目名称一致，所以脚本会进行重命名<br>-g 输入文件的大小，以M(兆)为单位<br>-d 数据库配置文件，即上面提到的保存Mysql信息的文件  </p><p>也可以直接用-h参数查看说明：</p><pre><code>           -i: the input file, must  fasta file           -p: the project name           -g: the size of genome, the unit is MB           -d: the database config file           -h: print this helpExample:           python /p299/user/og06/chenxiangjian1609/software/REPET/ready.py -i test.fa -p project -g 55 -d db.cfg</code></pre><p>REPET要求基因组文件为标准的fa文件，<strong>即每行的碱基数为60个，所以脚本里调用了Itools进行格式化（不管是否符合标准）</strong>。<br>同时还要求fa文件中，每段序列的名称以“&gt;XX_i”的形式命名。名称中<strong>不要出现除“_”以外的特殊符号</strong>。<br>运行完毕后会生成这样的一个文件目录结构(文件名称与实际参数有关)</p><pre><code>|-- db.cfg|-- genome.fa -&gt; /p299/user/og06/chenxiangjian1609/test_REPET/test3/test.fa|-- prj_1220.fa|-- step1_TEdenovo.sh|-- step2_TEannot.sh|-- step3_statistic.sh|-- step4_mask.sh|-- TEannot|   |-- change_status.sh|   |-- clean_jobs.sh|   |-- prj_1220.fa -&gt; /p299/user/og06/chenxiangjian1609/test_REPET/test_1220/prj_1220.fa|   |-- repbase20.05_aaSeq_cleaned_TE.fa|   |-- repbase20.05_ntSeq_cleaned_TE.fa|   |-- run_TEannot.sh|   |-- setEnv.sh|   `-- TEannot.cfg`-- TEdenovo    |-- change_status.sh    |-- clean_jobs.sh    |-- prj_1220.fa -&gt; /p299/user/og06/chenxiangjian1609/test_REPET/test_1220/prj_1220.fa    |-- run_TEdenovo.sh    |-- setEnv.sh    `-- TEdenovo.cfg</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>接下来依次运行项目目录下的4个shell脚本即可。<br>建议每一步都使用nohup运行，如：<br><code>nohup sh ./step4_mask.sh &amp;</code></p><h3 id="TEdenovo"><a href="#TEdenovo" class="headerlink" title="TEdenovo"></a>TEdenovo</h3><p>TEdenovo分为8个步骤，每一步的作用及产生的文件如下  </p><h4 id="step1-Genomic-sequences-are-cut-into-batches"><a href="#step1-Genomic-sequences-are-cut-into-batches" class="headerlink" title="step1: Genomic sequences are cut into batches"></a>step1: Genomic sequences are cut into batches</h4><p>这一步是将基因组分成一定数量的chunk，默认是分成200k一个chunk,每个batch之间有10k的overlap，考虑序列长度的因素，有一部分chunk的长度是低于200K的。然后将一定数量的chunk合成一个batch，多少个chunk合成一个batch，由配置文件TEdenovo.cfg中的 min_nb_seq_per_batch参数决定。水稻测试时，这个参数为25,所以每个batch的大小约为200k<em>25=5M，batch80(最后一个)由于chuank数量不足，大小约1.8M。<br>step1运行完毕会生成 <em>*REPET_rice_db</em></em> 文件夹：  </p><pre class="line-numbers language-sh"><code class="language-sh">|-- batches  #存放batch_*.fa文件的文件夹|-- REPET_rice_chunks.fa  #原始基因组分成chunk后，将所有chunk合成一个新基因组文件，由于chunk有重叠，所以比原始文件大`-- REPET_rice_chunks.map  #chunk的map文件，说明每个chuank的来源1 directory, 2 files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="step2-The-genome-is-aligned-to-itself-using-Blast"><a href="#step2-The-genome-is-aligned-to-itself-using-Blast" class="headerlink" title="step2: The genome is aligned to itself using Blast"></a>step2: The genome is aligned to itself using Blast</h4><p>第二步是将step1中的每个batch与由chunk合成的基因组进行自身比对寻找HSPs（high-scoring segment pairs），使用的是REPET自己封装的blast。这一步花费的时间较长，对于大基因组来说占用的内存也较大。<br>step2运行完毕会生成  <strong>REPET_rice_Blaster</strong> 文件夹  </p><pre class="line-numbers language-sh"><code class="language-sh">|-- REPET_rice.align.not_over.filtered  #保存HSPs的文件`-- TEdenovo.cfg #调用的配置文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="step2-structural-LTRs-retrotransposons-are-searched-in-each-batch-using-LTRharves"><a href="#step2-structural-LTRs-retrotransposons-are-searched-in-each-batch-using-LTRharves" class="headerlink" title="step2 structural: LTRs retrotransposons are searched in each batch using LTRharves"></a>step2 structural: LTRs retrotransposons are searched in each batch using LTRharves</h4><p>这一步是使用LTRharves软件从每个barch中寻找LTR转座子, Step 2 和 step 2 ‘structural’是独立的，不存在什么关系<br>step2 structural运行完毕会生成 <strong>REPET_rice_LTRharvest</strong> 文件夹，里面包含了每个batch的LTRharves结果，以fa文件的形式保存，结果较多，这里不作展示  </p><h4 id="step3-The-repetitives-HSP-from-BLAST-are-clustered-by-Recon-Grouper-and-or-Piler"><a href="#step3-The-repetitives-HSP-from-BLAST-are-clustered-by-Recon-Grouper-and-or-Piler" class="headerlink" title="step3 The repetitives HSP from BLAST are clustered by Recon, Grouper and/or Piler"></a>step3 The repetitives HSP from BLAST are clustered by Recon, Grouper and/or Piler</h4><p>使用Recon、Grouper、Piler这3个软件对blast出来的HSP进行聚类<br>这步运行完毕，每个方法都会生成对应的一个文件夹</p><pre class="line-numbers language-sh"><code class="language-sh">REPET_rice_Blaster_GrouperREPET_rice_Blaster_ReconREPET_rice_Blaster_Piler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每个文件夹内均包含一个 <strong>REPET_rice_Blaster_<method>_3elem_20seq.fa</method></strong>文件，里面含有序列信息，每个序列的名称表明了它所在的分类  </p><h4 id="Step-3-structural-The-predictions-from-LTRharvest-are-clustered-using-Blastclust-or-MCL"><a href="#Step-3-structural-The-predictions-from-LTRharvest-are-clustered-using-Blastclust-or-MCL" class="headerlink" title="Step 3 structural : The predictions from LTRharvest are clustered using Blastclust or MCL"></a>Step 3 structural : The predictions from LTRharvest are clustered using Blastclust or MCL</h4><p>使用blastclust或者MCL对LTRharvest的结果进行聚类，这一步的作用于上一步相同，生成的文件也是类似的，同样包含 <strong>REPET_rice_Blaster_<method>_3elem_20seq.fa</method></strong>文件 </p><h4 id="Step-4-A-multiple-alignment-is-computed-for-each-cluster-and-a-consensus-sequence-is-derived-from-each-multiple-alignment"><a href="#Step-4-A-multiple-alignment-is-computed-for-each-cluster-and-a-consensus-sequence-is-derived-from-each-multiple-alignment" class="headerlink" title="Step 4 : A multiple alignment is computed for each cluster, and a consensus sequence is derived from each multiple alignment"></a>Step 4 : A multiple alignment is computed for each cluster, and a consensus sequence is derived from each multiple alignment</h4><p>对前面步骤的4个聚类结果进行多序列比对，每一个多序列比对都会有一个consensus sequence。每个聚类方法都会生成一个对应的文件夹，而consensus sequece则保存在相应文件夹内的 <strong>REPET_rice_Blaster_Grouper_Map_consensus.fa</strong>文件内  </p><pre class="line-numbers language-sh"><code class="language-sh">REPET_rice_Blaster_Grouper_MapREPET_rice_Blaster_Recon_MapREPET_rice_Blaster_Piler_MapREPET_rice_LTRharvest_Blastclust_Map<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>由于进行了多序列比对，所以每个文件夹内都含有非常多的小文件，ls的时候会非常卡，不建议进行此类操作  </p><h4 id="Step-5-Particular-features-are-detected-on-each-consensus-such-as-structural-features-or-homology-with-known-TE-HMM-profiles-or-host-genes"><a href="#Step-5-Particular-features-are-detected-on-each-consensus-such-as-structural-features-or-homology-with-known-TE-HMM-profiles-or-host-genes" class="headerlink" title="Step 5 : Particular features are detected on each consensus, such as structural features or homology with known TE, HMM profiles or host genes"></a>Step 5 : Particular features are detected on each consensus, such as structural features or homology with known TE, HMM profiles or host genes</h4><p>这步其实是使用PASTEClassifier程序的第一步来寻找确定consensus的特征。<br>setp5运行完毕后会生成 <strong>REPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif</strong>文件夹，由于里面的文件会被step6用到并修改，所以在step6再说明文件。同时这步也会在mysql数据库里创建其他的一些表，如：REPET_rice_polyA_set、REPET_rice_ORF_map、REPET_rice_chk_TRF_set，后续步骤也会用到。  </p><h4 id="Step-6-The-consensus-are-classified-using-Wicker’s-classification"><a href="#Step-6-The-consensus-are-classified-using-Wicker’s-classification" class="headerlink" title="Step 6 : The consensus are classified using Wicker’s classification"></a>Step 6 : The consensus are classified using Wicker’s classification</h4><p>step6是根据step5确定的consensus的特征对consensus进行分类，使用的是REPET自带的PASTEC tool。PASTEC分类是基于Wicker’s classification，所以如果分类出来的TEs的命名规则为：  </p><pre class="line-numbers language-s"><code class="language-s">{Wicker's classification code}_{consensus name}{Wicker's classification code}-{completeness}_{consensus name}{Wicker's classification code}-{completeness}-{potential chimeric}_{consensus name}{Wicker's classification code}-{completeness}-{potential chimeric}_{consensus name}_{reversed}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>样例： </p><pre class="line-numbers language-sh"><code class="language-sh">Complete Copia retrotransposon : RLX-comp_ProjectName-L-B270-Map20LARD : RXX-LARD_ProjectName-B-R270-Map3Incomplete TIR: DTX-incomp_ProjectName-B-P350-Map5Retrotransposon: RXX_ProjectName-L-B28-Map1TIR potentially chimeric: DTX-comp-chim_ProjectName-B-G78-Map6Host gene: PotentialHostGene_ProjectName-B-R52-Map3Not classified: noCat_ProjectName-B-R878-Map8Not classified re-qualified like a RLX: noCat-RLX-like_ProjectName-B-G143-Map12Incomplete retrotransposon originally found in negative strand: RLX-incomp_RLX-incomp_ProjectName-L-B230-Map1_reversed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>step6运行完毕后，<strong>REPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif</strong>里包含2个文件夹：</p><pre><code>|-- classifConsensus  |   |-- REPET_rice_Blaster_GrpRecPil_Struct_Map_consensus.fa -&gt; ../detectFeatures/REPET_rice_Blaster_GrpRecPil_Struct_Map_consensus.fa  #consensus的fa文件|   |-- REPET_rice.classif  #重复序列分类结果文件|   |-- REPET_rice.classif_stats.txt #重复序列分类结果统计文件|   |-- REPET_rice_denovoLibTEs.fa -&gt; REPET_rice_withoutRedundancy_negStrandReversed_WickerH.fa #denovo方式最后得到的TE library|   |-- REPET_rice_withoutRedundancy.classif  #去冗余的分类结果文件|   |-- REPET_rice_withoutRedundancy.classif_stats.txt  #去冗余的分类结果统计文件|   |-- REPET_rice_withoutRedundancy.fa  #去冗余结果的fa文件|   |-- REPET_rice_withoutRedundancy_negStrandReversed.classif   #去冗余并负义链反转的分类结果文件|   |-- REPET_rice_withoutRedundancy_negStrandReversed.fa  #去容易并负义链反转的fa文件|   |-- REPET_rice_withoutRedundancy_negStrandReversed_WickerH.classif #以Wicker code开头命名的分类结果文件|   |-- REPET_rice_withoutRedundancy_negStrandReversed_WickerH.classif_stats.txt #上一个文件的统计结果|   |-- REPET_rice_withoutRedundancy_negStrandReversed_WickerH.fa #最终结果的fa文件|   `-- TEdenovo.cfg -&gt; ../../TEdenovo.cfg`-- detectFeatures    |-- ORF     |   `-- REPET_rice.ORF.map #ORF结果集    |-- polyA    |   `-- REPET_rice.polyA.set  # PolyA结果集    |-- REPET_rice_Blaster_GrpRecPil_Struct_Map_consensus.fa    |-- SSR    |   `-- REPET_rice.SSR.set #SSR结果集    |-- TEdenovo.cfg -&gt; ../../TEdenovo.cfg    `-- TR        `-- REPET_rice.TR.set #TR结果集6 directories, 19 files</code></pre><p>生成的classif文件里没有表头，通过查询mysql数据库里的相应的表，各列的表头如下：</p><p>seq_name | length | strand | status | class_classif | order_classif | completeness | evidence<br>—|— | —|—|—|—|—|—|—|—|—|—<br>noCat_REPET_rice-B-G10008-Map3 | 516 | .| ok| noCat| noCat| NA| CI=NA; struct=(SSRCoverage=0.21)<br>SSR_REPET_rice-B-G10016-Map3 | 623| .| ok| NA| SSR| NA| CI=100; struct=(TElength: &gt;100bps; SSRCoverage=0.77)<br>DXX-MITE_REPET_rice-B-G10034-Map4| 590| .| ok| II| MITE| NA| CI=20; struct=(TElength: &lt;700bps; TermRepeats: termTIR: 34); other=(TermRepeats: non-termLTR: 115; SSRCoverage=0.00)    </p><p><strong>Wicker’s code：</strong>   </p><pre class="line-numbers language-sh"><code class="language-sh">Transposable elements :    Class I (RXX)        DIRS (RYX)        LARD (RXX-LARD)        LINE (RIX)        LTR (RLX)        PLE (RPX)        SINE (RSX)        TRIM (RXX-TRIM)    Class II (DXX)        Crypton (DYX)        Helitron (DHX)        MITE (DXX-MITE)        Maverick (DMX)        TIR (DTX)    noCat (sequence not classified at class AND order levels)     XXX (sequence not classified at class level and with potential several orders)Not transposable elements :    PotentialHostGene    rDNA    SSR<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Step-7-SSR-and-under-represented-unclassified-consensus-are-filtered"><a href="#Step-7-SSR-and-under-represented-unclassified-consensus-are-filtered" class="headerlink" title="Step 7 : SSR and under-represented unclassified consensus are filtered"></a>Step 7 : SSR and under-represented unclassified consensus are filtered</h4><p>这一步是将上一步得到的最后结果进行SSR和低置信度的未分类consensus进行过滤<br>运行完毕后生成 <strong>REPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif_Filtered</strong> 文件夹：</p><pre class="line-numbers language-sh"><code class="language-sh">|-- classifFileFromList.classif  #过滤后的分类文件|-- classifFileFromList.classif_stats.txt  #过滤后的分类统计文件|-- REPET_rice_denovoLibTEs_filtered.fa  #过滤后的序列文件`-- TEdenovo.cfg -> /p299/user/og06/chenxiangjian1609/test_REPET/REPET_rice364/TEdenovo/TEdenovo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>文件格式与step6相同</p><h4 id="Step-8-The-consensus-are-clustered-into-families-to-facilitate-manual-curation-using-Blastclust-or-MCL"><a href="#Step-8-The-consensus-are-clustered-into-families-to-facilitate-manual-curation-using-Blastclust-or-MCL" class="headerlink" title="Step 8 : The consensus are clustered into families to facilitate manual curation using Blastclust or MCL"></a>Step 8 : The consensus are clustered into families to facilitate manual curation using Blastclust or MCL</h4><p>使用Blastclust或MCL对denovo consensus进行聚类，每种方法都会生成一个对应的文件夹  </p><pre><code>REPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif_Filtered_BlastclustREPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif_Filtered_MCL</code></pre><p>以REPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif_Filtered_Blastclust为例：</p><pre class="line-numbers language-sh"><code class="language-sh">|-- REPET_rice_denovoLibTEs_filtered_Blastclust_clusterCons.tab #聚类后表格，每一行代表一个cluster|-- REPET_rice_denovoLibTEs_filtered_Blastclust.fa  #聚类后的序列文件，序列名称里的Blc1，即代表cluster的名称|-- REPET_rice_denovoLibTEs_filtered_Blastclust_globalStatsPerCluster.txt #对所有cluster的统计信息|-- REPET_rice_denovoLibTEs_filtered_Blastclust.statsPerCluster.tab #每个cluster的统计信息|-- REPET_rice_denovoLibTEs_filtered.fa -> ../REPET_rice_Blaster_GrpRecPil_Struct_Map_TEclassif_Filtered/REPET_rice_denovoLibTEs_filtered.fa `-- TEdenovo.cfg -> /p299/user/og06/chenxiangjian1609/test_REPET/REPET_rice364/TEdenovo/TEdenovo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ste8、step7、step6生成的序列文件均可以作为TEannot的参考TEs library。一般情况还是使用step8的结果文件。  </p><h3 id="TEannot"><a href="#TEannot" class="headerlink" title="TEannot"></a>TEannot</h3><p>TEannot同样分为8个步骤</p><h4 id="Step-1-genomic-sequence-and-data-banks-preparation"><a href="#Step-1-genomic-sequence-and-data-banks-preparation" class="headerlink" title="Step 1 genomic sequence and data banks preparation"></a>Step 1 genomic sequence and data banks preparation</h4><p>这一步与TEdenovo的step1类似，也是将基因组分成一定数量的batch，不同的是还增加了一个将batch随机化的的内容，所以生成这一步会在<strong>REPET_rice_db</strong>生成两个文件夹：</p><pre><code>|-- batches  #分割后的batch|-- batches_rnd  #随机化后的batch|--other files</code></pre><h4 id="Step2-Align-the-reference-TE-sequences-on-each-chunk"><a href="#Step2-Align-the-reference-TE-sequences-on-each-chunk" class="headerlink" title="Step2 Align the reference TE sequences on each chunk"></a>Step2 Align the reference TE sequences on each chunk</h4><p>这一步是使用Blaster、RepeatMasker、CENSOR这3种软件将chunk比对到参考的TE library（TEdenovo生成的结果，也可以使用其他的TE library）。由于CENSOR安装不成功，所以只用到了Blaster和RepeatMasker。除了正常的chunk比对到TE library，随机化的chunk也要和TE library做比对。所以这步会生成两个文件夹：</p><pre class="line-numbers language-sh"><code class="language-sh">REPET_rice_TEdetectREPET_rice_TEdetect_rnd<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在两个文件夹内，每个方法都会生成相应的文件夹，里面包含自己的比对结果  </p><h4 id="Step-3-Filter-and-combine-HSP"><a href="#Step-3-Filter-and-combine-HSP" class="headerlink" title="Step 3 Filter and combine HSP"></a>Step 3 Filter and combine HSP</h4><p>这一步是从step2的结果中过滤并合并HSPs, 然后<strong>REPET_rice_TEdetect</strong>目录下生成一个<strong>Comb</strong>的目录，里面包含每个batch比对的<strong>newScores</strong>文件和<strong>newScores.clean_match.map</strong>  </p><h4 id="Step-4-Search-for-SSR-amp-Step-5-Merge-SSR-annotations"><a href="#Step-4-Search-for-SSR-amp-Step-5-Merge-SSR-annotations" class="headerlink" title="Step 4: Search for SSR &amp; Step 5 Merge SSR annotations"></a>Step 4: Search for SSR &amp; Step 5 Merge SSR annotations</h4><p>使用TRF、REPEATMASKER、Mreps这3个软件寻找基因组中的SSR, 然后将这3个软件的结果整合，并将数据存入mysql数据库<br>运行结束会在生成<strong>REPET_rice_SSRdetect</strong>文件夹 </p><pre class="line-numbers language-sh"><code class="language-sh">.|-- Comb|-- Mreps|-- RMSSR`-- TRF<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各目录内包含各软件的结果，comb目录内不含实际数据，整合后的数据在数据库中  </p><h4 id="Step-6-Comparison-with-data-banks"><a href="#Step-6-Comparison-with-data-banks" class="headerlink" title="Step 6 Comparison with data banks"></a>Step 6 Comparison with data banks</h4><p>这一步是将各batch比对到已有的重复序列数据库，水稻数据测试使用的是repbase的数据库，需要使用REPET专用的版本。分别比对到核酸数据和氨基酸数据，运行后会在<strong>REPET_rice_TEdetect</strong>目录下生成2个文件夹：</p><pre><code>bankBLRtxbankBLRx</code></pre><h4 id="Step-7-Remove-spurious-HSPs-and-long-join-procedure"><a href="#Step-7-Remove-spurious-HSPs-and-long-join-procedure" class="headerlink" title="Step 7 Remove spurious HSPs and long join procedure"></a>Step 7 Remove spurious HSPs and long join procedure</h4><p>这一步会去除假的HSPs（比如全部由SSR组成的HSPs）并加入由片段链接起来的TEs<br>这步不会生成任何文件，但是在mysql里会生成相应的表，数据都存在数据库中  </p><h4 id="Step-8-TE-annotation-export"><a href="#Step-8-TE-annotation-export" class="headerlink" title="Step 8 TE annotation export"></a>Step 8 TE annotation export</h4><p>从最终的mysql数据库中的表格里导出TE的注释，可以选择生成GFF3或者gameXML的格式，每种格式都会生成对应的文件夹  </p><pre class="line-numbers language-sh"><code class="language-sh">REPET_rice_gameXMLchrREPET_rice_GFF3chr<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>以REPET_rice_GFF3chr为例：</p><pre class="line-numbers language-sh"><code class="language-sh">|-- annotation_tables.txt|-- chr01.gff3|-- chr02.gff3|-- chr03.gff3|-- chr04.gff3|-- chr05.gff3|-- chr06.gff3|-- chr07.gff3|-- chr08.gff3|-- chr09.gff3|-- chr10.gff3|-- chr11.gff3|-- chr12.gff3`-- chrnew01.gff3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每条染色体都对应一个文件  </p><h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><ol><li><p>TEdenovo和TEannot中均有寻找SSR的步骤：<br>在TEdenovo的step5中，是在step4生成的重复序列的一致性序列中寻找SSR，目的是为了区分真正的TEs和SSRs,并在step7里将SSR过滤掉<br>在TEannot中，是在整个基因组当中寻找SSR，目的是为了过滤掉某些看起来像是TE annotation但实际是完全由SSR覆盖的序列   </p></li><li><p>chunk和batch的关系<br>在step1中，会将基因组分成一定数量的chunk，每个chunk大小为200k, 每个chunk之间有10k的overlap。<br>batch是一定数量的chunk的集合，这个数量的定义是：  </p></li></ol><p><strong>minimum number of chunks per batch launched in parallel</strong><br>即每个batch运行时，并行的最小chunk数。<br>REPET中实际使用的其实是chunk，所有的操作都是基于chunk。batch只是代表了并行运行的chunk的数量</p><h3 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h3><h4 id="note1："><a href="#note1：" class="headerlink" title="note1："></a>note1：</h4><p>REPET会自动把任务投递到集群上运行，在TEdenovo.cfg和TEannot.cfg中均可以修改相应的集群资源参数，包括使用的节点和要求的内存、CPU。ready.py那个脚本已经根据基因组大小对要求的资源做了一个粗略的区分。实际运行时如果觉得不妥当也可以人工去修改。<br><img src="http://oht4p9vad.bkt.clouddn.com/QQ%E5%9B%BE%E7%89%8720161219110044.png" alt="resource">  </p><h4 id="note2"><a href="#note2" class="headerlink" title="note2"></a>note2</h4><p>TEdenovo和TEannot各自均分为8小步，每一步运行完毕都会在输出日志文件中显示成功运行，如：<br><img src="http://oht4p9vad.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161219110804.png" alt="success"><br>如果中间运行出错，也可以寻找相应步骤的日志文件，查看错误原因，然后重新运行。可以根据实际情况选择重新运行单步，或者全部重新运行。在TEdenovo和TEannot文件夹下，还有<strong>run_TExxxxx.sh</strong>,可以从这个文件运行。  </p><p><u>重新运行前，请一定要运行下TEdenovo或TEannot目录下的<strong>clean_jobs.sh</strong>这个脚本，清除掉数据库中jobs表里的数据，不然之前的错误任务是不会停止的。</u></p><h4 id="note3"><a href="#note3" class="headerlink" title="note3"></a>note3</h4><p>REPET投递的任务有时候会莫名的停止，特别是在做比对的时候。一般分为两种情况： </p><ol><li>第一种是由于节点资源的原因，任务跑失败了，REPET会进行重投，默认重投是2次，2次均失败后，任务就会停止。所以修改了REPET源码里的重投次数，改成了6次。应该能避免这一类问题。</li><li>第二种就比较诡异了，REPET调用的程序（如blaster)其实已经运行结束了，结果文件也产生了。但是数据库的jobs表中status字段依然还是”running”。而且通过qsee命令查看这个任务，也是运行的状态，但是cpu时间已经不动了。导致程序没有继续跑下去。所以这个时候需要去修改mysql表里的状态，可以使用TEdenovo或TEannot目录下的<strong>change_status.sh</strong>脚本：<pre class="line-numbers language-shell"><code class="language-shell">sh ./change_status.sh xxxxxxx(通过qsee等命令看到的job_ID)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>之后程序就能继续运行。这个问题目前都是随机出现，不知道原因出在哪里。</li></ol><h4 id="note4"><a href="#note4" class="headerlink" title="note4"></a>note4</h4><p>如果遇上Grouper(TEdenovo-step3)报下面这类错误：  </p><pre><code>grouper: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&#39; not found (required by grouper)</code></pre><p>这个错误是集群环境的原因，所以直接在环境变量中加入动态库就可以了。具体就在自己的.zshrc或.bashrc里加入</p><pre><code>GCC_LIB=&quot;/nfs2/config/gcc/gcc-4.9.2/lib/:/nfs2/config/gcc/gcc-4.9.2/lib64/&quot;export PATH=&quot;$GCC_LIB:$PATH&quot;  </code></pre><h4 id="note5"><a href="#note5" class="headerlink" title="note5"></a>note5</h4><p>Piler（TEdenovo-step3）由于自身软件原因，当基因组大小超过500M的时候，就会报“out of memory”的错误。<br>此时可以直接注释掉运行Piler的步骤。<br>同时将后续的步骤中的<strong>-GrpRecPil</strong>参数修改为<strong>-GrpRec</strong>。  </p><h3 id="Advance"><a href="#Advance" class="headerlink" title="Advance"></a>Advance</h3><p>由于REPET最后的输出结果只有GFF3文件或者gameXML文件，缺少统计信息。所以写了个脚本对输出的GFF3文件进行统计，输出结果样例如下：<br><img src="http://oht4p9vad.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20161219113907.png" alt="statistic">  </p><p>为了方便后续的基因注释等流程，还增加了一步使用repeatmasker对基因组文件中的重复序列进行注释的步骤（step4）。最后会在项目目录下输出xxxx.masked.fa文件。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>REPET官网：<a href="https://urgi.versailles.inra.fr/Tools/REPET" target="_blank" rel="noopener">https://urgi.versailles.inra.fr/Tools/REPET</a><br>TEdenovo文档： <a href="https://urgi.versailles.inra.fr/Tools/REPET/TEdenovo-tuto" target="_blank" rel="noopener">https://urgi.versailles.inra.fr/Tools/REPET/TEdenovo-tuto</a><br>TEannot文档： <a href="https://urgi.versailles.inra.fr/Tools/REPET/TEannot-tuto" target="_blank" rel="noopener">https://urgi.versailles.inra.fr/Tools/REPET/TEannot-tuto</a><br>demo服务器路径：/p299/user/og06/chenxiangjian1609/test_REPET/test_1220</p><p>REPET的文档十分详细，包括每一小步是做什么的，以及每一步运行的命令均有说明。<br>ready.py生成的配置文件基本是按照默认参数生成的，实际运行中可以参考文档，对生成的配置文件进行修改。</p>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
            <tag> 科研 </tag>
            
            <tag> REPET </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重复序列类型</title>
      <link href="/2018/09/29/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/09/29/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="重复序列类型"><a href="#重复序列类型" class="headerlink" title="重复序列类型"></a>重复序列类型</h2><p>基因组中的重复序列依据其序列特征可以分为两类：  </p><ul><li>1.tandem repeats（串联重复序列）  </li><li>2.dispersed repeats（分散重复序列） </li></ul><p>分散重复序列的在基因组中主要是transposable elements(TEs)，也就是转座子。</p><h2 id="串联重复序列"><a href="#串联重复序列" class="headerlink" title="串联重复序列"></a>串联重复序列</h2><p>串联重复序列按照其长度可以分为两类：</p><ol><li>microsatellites or simple sequence repeats（SSR）：由1-6bp的短重复单元组成</li><li>minisatellites：由10-60bp的长重复单元组成  </li></ol><h3 id="转座子"><a href="#转座子" class="headerlink" title="转座子"></a>转座子</h3><p>转座子根据其转座的媒介和转座的机制，可以分成两大类：<br>第一类是以RNA为媒介，通过“copy and paste”机制进行转座<br>第二类是以DNA为媒介，通过“cut and paste”机制进行转座  </p><p>在这两类中，又根据序列的结构特征可以进一步的进行分类<br>在第一类classⅠ中可以分为2类：<br>1.Long terminal repeat retrotransposon（LTR）<br>2.Non-LTR retrotransposon  </p><p>在第二类classⅡ中，目前比较确定的可以分成3类：<br>1.TIR(Terminal Inverted Repeat)<br>2.MITE(miniature inverted repeat transposable elements)<br>3.Helitron  </p><h4 id="LTR转座子"><a href="#LTR转座子" class="headerlink" title="LTR转座子"></a>LTR转座子</h4><p>LTR转座子，其基本特征是在3’末端有PBS结构，在5’末端有PPT结构，长度一般5-9kb之间，有些有编码能力，有些没有编码能力。根据结构的不同，又分为几个不同的子类型</p><h4 id="non-LTR转座子"><a href="#non-LTR转座子" class="headerlink" title="non-LTR转座子"></a>non-LTR转座子</h4><p>non-LTR转座子分为2类：<br>1.LINE（long interspersed nuclear elements）<br>2.SINE（short interspersed elements）<br>non-LTR的结构特征是在3’末端有PolyA的尾巴，LINE相比SINE是有编码能力的，序列中间有ORF的存在。LINE的长度一般在5-8kb，SINE的长度一般在80-500bp，同样，LINE和SINE还可以再根据结构继续细分成不同的类型。</p><h4 id="DNA转座子"><a href="#DNA转座子" class="headerlink" title="DNA转座子"></a>DNA转座子</h4><p>TIR转座子的结构特征是在序列两端有TIR（Terminal Inverted Repeat）序列，以及在序列中间有转座酶的序列，长度小于5kb</p><p>MITE与TIR转座子相比，序列中间没有转座酶序列。比较特别的是，MITE虽然是DNA为转座媒介，但是其转座机制是“copy and paste”，长度在500bp左右</p><p>Helitron的结构比较特殊，在其序列中间有一个RPAI Helicase，在3‘末端附近还有一个发夹结构，长度在5kb左右</p><p>随着时间的发展，重复序列的分类也越来越精细，REPET软件中用到的Wicker’s classification分得更为详细（见最后） </p><h2 id="重复序列鉴定软件"><a href="#重复序列鉴定软件" class="headerlink" title="重复序列鉴定软件"></a>重复序列鉴定软件</h2><p>重复序列鉴定软件主要分为两类<br>一类是基于已有的数据库或结构特征进行鉴定<br>一类是采用从头预测的方法进行鉴定<br>一些软件如下：</p><ul><li><p>基于已知的转座子数据库进行鉴定；<br>RepeatMasker<br>GREEDIER  </p></li><li><p>基于转座子的结构特征进行鉴定（主要用于TEs）；<br>LTR：LTRharvest、LTR_PAR、FIND_LTR、LTR-FINDER<br>non-LTR：TSDFINDER、SINEDR、RTANALYZER<br>MITEs：FINDMITE、TRANSPO、MITE-Hunter<br>Helitrons：HelitronFinder、HelitronScanner  </p></li><li><p>采用从头预测的方法对重复序列进行预测；<br>自我比对方法：RECON、PILER<br>Kmer法：REAS、REPEATSCOUT  </p></li><li><p>对串联重复序列进行鉴定<br>TRF<br>TRAP  </p></li></ul><p>此外，还可以参考这篇<a href="http://www.nature.com/hdy/journal/v104/n6/fig_tab/hdy2009165t1.html#figure-title" target="_blank" rel="noopener">综述中罗列的软件</a>，非常全面。不过因为时间的原因，有些可能已经失效了。</p><h2 id="pipeline程序"><a href="#pipeline程序" class="headerlink" title="pipeline程序"></a>pipeline程序</h2><p>REPET集成并使用了多个软件的结果，包括RECON、Pipler、Grouper、REPEATMASKER、Blaster、TRF、MREPS等。<br>其他还有一些pipeline程序，如：  </p><p><strong>RepeatModeler</strong>：RepeatMasker、RECON、RepeatScout 、TRF、NSEG、Blast  </p><p><strong>DAWGPAWS</strong>(用于植物注释）:LTR_STRUC, LTR_FINDER, LTR_PAR, FIND_LTR, FINDMITE, TRF, REPSEEK, REPEATMASKER and TENEST  </p><p><strong>RETROPRED</strong>（鉴定LINE和SINE）： PALS、PILER、MEME、SNNS </p><h2 id="Wicker’s-classification"><a href="#Wicker’s-classification" class="headerlink" title="Wicker’s classification"></a>Wicker’s classification</h2><pre><code>Transposable Element    ClassI        LTR retrotransposon            LTR                Copia                    TCN1-6                    TCN1-7                    TCN1-8                    TCN1-9                Gypsy                    TCN1-1                    TCN1-2                    TCN1-3                    TCN1-4                    TCN1-5                    TCN1-10                Bel-Pao                Retrovirus                ERV                    ERV1                    ERV2                    ERV3                    Lentivirus                    ERV4            DIRS                DIRS                Ngaro                VIPER            PLE                Penelope            LARD            TRIM        Non-LTR retrotransposon            LINE                R2                    CRE                    R4                    Hero                    NeSL                    R2                L1                    Proto1                    L1                    Tx1                RTE                    RTETP                    Proto2                    RTEX                    RTE                I                    Outcast                    Ingi                    I                    Nimb                    Tad1                    Loa                    R1                Jockey                    Jockey                    Rex1                    CR1                    L2                    L2A                    L2B                    Daphne                    Crack                ?                    RandI                    Vingi            SINE                SINE2/tRNA                SINE1/7SL                SINE3/5S                SINE4            ?                ?                    Ambal                    Kiri    ClassII        Subclass1            TIR                Tc1-Mariner                hAT                Mutator                Merlin                Transib                P                PiggyBac                PIF-Harbinger                MuDR                CACTA                    EnSpm            MITE            Crypton                CryptonA                CryptonF                CryptonI                CryptonS                CryptonV        Subclass2            Helitron                Helitron            Maverick                Maverick            Sola                Sola1                Sola2                Sola3        ?            ?                Transib                Novosib                Mirage                Rehavkus                Kolobok                ISL2EU                Chapaev                Zator                Ginger1                Ginger2/TDD                Academ                Zisupton                IS3EU                Dada</code></pre>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
            <tag> 重复序列 </tag>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow小尝试</title>
      <link href="/2018/07/26/tensorflow%E5%B0%8F%E5%B0%9D%E8%AF%95/"/>
      <url>/2018/07/26/tensorflow%E5%B0%8F%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>win10 64位</li><li>GTX960m</li><li>Python 3.5.2 :: Anaconda 4.2.0 (64-bit)</li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>通过查看<a href="https://www.tensorflow.org/install/install_windows" target="_blank" rel="noopener">TensorFlow Windows安装文档</a>，想要安装<code>TensorFlow-GPU</code>版本的前提是有<code>Nvidia</code>显卡并安装了以下依赖:</p><ul><li>CUDA® Toolkit 9.0</li><li>支持CUDA® Toolkit 9.0的显卡驱动</li><li>cuDNN v7.0</li><li>具有CUDA Compute Capability 3.0 或更高版本的显卡(GTX960m 的Compute Capability为5.0，满足)</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CUDA-Toolkit安装"><a href="#CUDA-Toolkit安装" class="headerlink" title="CUDA Toolkit安装"></a>CUDA Toolkit安装</h3><p>从<a href="https://developer.nvidia.com/cuda-90-download-archive?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exenetwork" target="_blank" rel="noopener">CUDA Toolkit</a>下载CUDA Tookit的9.0版本。下载完直接默认安装即可，安装完成后会自动加入环境变量。</p><p>如果电脑中没有<code>Visual Studio</code>，安装之前会提示你没有安装<code>Visual Studio</code>。这个应该可装可不装，不影响使用(<strong>到目前为止</strong>)</p><p>安装完成后，在Power Shell里运行：</p><pre class="line-numbers language-bash"><code class="language-bash">nvcc -V输出：nvcc: NVIDIA <span class="token punctuation">(</span>R<span class="token punctuation">)</span> Cuda compiler driverCopyright <span class="token punctuation">(</span>c<span class="token punctuation">)</span> 2005-2017 NVIDIA CorporationBuilt on Fri_Sep__1_21:08:32_Central_Daylight_Time_2017Cuda compilation tools, release 9.0, V9.0.176<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表示安装成功</p><h3 id="显卡驱动"><a href="#显卡驱动" class="headerlink" title="显卡驱动"></a>显卡驱动</h3><p>一般情况下，显卡驱动都已经安装好了。<br>如需安装，可以从<a href="https://www.geforce.cn/drivers" target="_blank" rel="noopener">显卡驱动</a>下载</p><h3 id="cuDNN安装"><a href="#cuDNN安装" class="headerlink" title="cuDNN安装"></a>cuDNN安装</h3><p>从 <a href="https://developer.nvidia.com/cudnn" target="_blank" rel="noopener">NVIDIA cuDNN</a>下载TensorFlow-GPU版本指定的7.0版本(最新版为7.1)。下载cuDNN需要注册Nvidia Developer账号。</p><p>下载完成后解压，然后将解压后的文件放入<strong>上述</strong><code>CUDA toolkit</code>安装目录对应的目录下。</p><h3 id="TensorFlow-GPU安装"><a href="#TensorFlow-GPU安装" class="headerlink" title="TensorFlow-GPU安装"></a>TensorFlow-GPU安装</h3><p>直接在Power Shell里运行：</p><pre class="line-numbers language-bash"><code class="language-bash">pip <span class="token function">install</span> --upgrade tensorflow-gpu<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可能会因为网络等原因安装失败，可以尝试多安装几次。（本人装了3次才成功……）</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>安装完TensorFlow后，可以使用<code>MNIST手写数字识别</code>来测试。代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token comment" spellcheck="true">## 导入MNIST数据集，查看训练集，测试集，验证集的情况</span><span class="token keyword">from</span> tensorflow<span class="token punctuation">.</span>examples<span class="token punctuation">.</span>tutorials<span class="token punctuation">.</span>mnist <span class="token keyword">import</span> input_datamnist <span class="token operator">=</span> input_data<span class="token punctuation">.</span>read_data_sets<span class="token punctuation">(</span><span class="token string">"MNIST_data/"</span><span class="token punctuation">,</span> one_hot<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>mnist<span class="token punctuation">.</span>train<span class="token punctuation">.</span>images<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> mnist<span class="token punctuation">.</span>train<span class="token punctuation">.</span>labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>mnist<span class="token punctuation">.</span>test<span class="token punctuation">.</span>images<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> mnist<span class="token punctuation">.</span>test<span class="token punctuation">.</span>labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>mnist<span class="token punctuation">.</span>validation<span class="token punctuation">.</span>images<span class="token punctuation">.</span>shape<span class="token punctuation">,</span> mnist<span class="token punctuation">.</span>validation<span class="token punctuation">.</span>labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 输入数据</span>sess <span class="token operator">=</span> tf<span class="token punctuation">.</span>InteractiveSession<span class="token punctuation">(</span><span class="token punctuation">)</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>placeholder<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">,</span> <span class="token punctuation">[</span>None<span class="token punctuation">,</span> <span class="token number">784</span><span class="token punctuation">]</span><span class="token punctuation">)</span>W <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">784</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>b <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 实现Softmax Regression算法</span>y <span class="token operator">=</span> tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>softmax<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>x<span class="token punctuation">,</span> W<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 损失函数</span>y_ <span class="token operator">=</span> tf<span class="token punctuation">.</span>placeholder<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">,</span> <span class="token punctuation">[</span>None<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span>cross_entropy <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span><span class="token operator">-</span>tf<span class="token punctuation">.</span>reduce_sum<span class="token punctuation">(</span>y_ <span class="token operator">*</span> tf<span class="token punctuation">.</span>log<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> reduction_indices<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 初始化</span>train_step <span class="token operator">=</span> tf<span class="token punctuation">.</span>train<span class="token punctuation">.</span>GradientDescentOptimizer<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>minimize<span class="token punctuation">(</span>cross_entropy<span class="token punctuation">)</span>tf<span class="token punctuation">.</span>global_variables_initializer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 训练</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    batch_xs<span class="token punctuation">,</span> batch_ys <span class="token operator">=</span> mnist<span class="token punctuation">.</span>train<span class="token punctuation">.</span>next_batch<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>    train_step<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> batch_xs<span class="token punctuation">,</span> y_<span class="token punctuation">:</span> batch_ys<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">## 准确率</span>correct_predition <span class="token operator">=</span> tf<span class="token punctuation">.</span>equal<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>y<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tf<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>y_<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>accuracy <span class="token operator">=</span> tf<span class="token punctuation">.</span>reduce_mean<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>correct_predition<span class="token punctuation">,</span> tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>accuracy<span class="token punctuation">.</span>eval<span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span> mnist<span class="token punctuation">.</span>test<span class="token punctuation">.</span>images<span class="token punctuation">,</span> y_<span class="token punctuation">:</span>mnist<span class="token punctuation">.</span>test<span class="token punctuation">.</span>labels<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行后输出很多WARNING，因为代码还是基于tensorflow1.0的。并且会在运行目录下生成<code>MNIST_data</code>文件夹。</p><p>有意义的输出如下：</p><pre class="line-numbers language-bash"><code class="language-bash">Created TensorFlow device <span class="token punctuation">(</span>/job:localhost/replica:0/task:0/device:GPU:0 with 1420 MB memory<span class="token punctuation">)</span> -<span class="token operator">></span> physical GPU <span class="token punctuation">(</span>device: 0, name: GeForce GTX 960M, pci bus id: 0000:01:00.0, compute capability: 5.0<span class="token punctuation">)</span>Successfully downloaded train-images-idx3-ubyte.gz 9912422 bytes.Extracting MNIST_data/train-images-idx3-ubyte.gzSuccessfully downloaded train-labels-idx1-ubyte.gz 28881 bytes.Extracting MNIST_data/train-labels-idx1-ubyte.gzSuccessfully downloaded t10k-images-idx3-ubyte.gz 1648877 bytes.Extracting MNIST_data/t10k-images-idx3-ubyte.gzSuccessfully downloaded t10k-labels-idx1-ubyte.gz 4542 bytes.Extracting MNIST_data/t10k-labels-idx1-ubyte.gz<span class="token punctuation">(</span>55000, 784<span class="token punctuation">)</span> <span class="token punctuation">(</span>55000, 10<span class="token punctuation">)</span><span class="token punctuation">(</span>10000, 784<span class="token punctuation">)</span> <span class="token punctuation">(</span>10000, 10<span class="token punctuation">)</span><span class="token punctuation">(</span>5000, 784<span class="token punctuation">)</span> <span class="token punctuation">(</span>5000, 10<span class="token punctuation">)</span>0.9162<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见已经是使用GPU来运行了。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> tensorflow </tag>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python提取GFF3文件信息</title>
      <link href="/2018/04/12/python%E6%8F%90%E5%8F%96GFF3%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/"/>
      <url>/2018/04/12/python%E6%8F%90%E5%8F%96GFF3%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="GFF3文件"><a href="#GFF3文件" class="headerlink" title="GFF3文件"></a>GFF3文件</h2><p>想要从GFF3文件中提取的信息为重复序列的种类，数量，以及bp数。<br>GFF3文件分为9列，这次用到是第2、4、5、9列，分别代表来源，序列起始位置，结束位置，以及属性。<br>重复序列的种类可以从第9列属性中提取，bp数以（结束位置-起始位置+1）进行计算，数量则在过程中统计。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按行读入GFF3文件，以”<strong>\t</strong>“符号分解。首先通过第2列，判断来源，有3种来源：  </p><ol><li>TEs</li><li>SSRs</li><li>blastx or tblasts</li></ol><p>不同的来源，后缀不同，通过判断相应的字符串是否在第2列字符串中来判断是哪种来源。再通过第9列属性字符串，判断相应的分类代码字符串是否在其中，如果在其中，则将分类代码放入一个列表，然后以分类代码为键，bp数为值生成字典。<br>for循环不断读入，列表增长，字典合并，最后将列表唯一化，通过Counter类生成相应的字典，这个字典的值就是各分类的数量。  </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>生成字典是通过事先定义一个函数的方式实现的：  </p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">return_TEs</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    TEs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'RYX'</span><span class="token punctuation">,</span> <span class="token string">'RXX-LARD'</span><span class="token punctuation">,</span> <span class="token string">'RIX'</span><span class="token punctuation">,</span> <span class="token string">'RLX'</span><span class="token punctuation">,</span> <span class="token string">'RPX'</span><span class="token punctuation">,</span> <span class="token string">'RSX'</span><span class="token punctuation">,</span> <span class="token string">'RXX-TRIM'</span><span class="token punctuation">,</span> <span class="token string">'DYX'</span><span class="token punctuation">,</span> <span class="token string">'DHX'</span><span class="token punctuation">,</span>    <span class="token string">'DXX-MITE'</span><span class="token punctuation">,</span> <span class="token string">'DMX'</span><span class="token punctuation">,</span> <span class="token string">'DTX'</span><span class="token punctuation">,</span> <span class="token string">'RXX-chim'</span><span class="token punctuation">,</span> <span class="token string">'DXX-chim'</span><span class="token punctuation">,</span> <span class="token string">'noCat'</span><span class="token punctuation">]</span>    <span class="token punctuation">(</span>seqid<span class="token punctuation">,</span> source<span class="token punctuation">,</span> seqtype<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> score<span class="token punctuation">,</span> strand<span class="token punctuation">,</span> phase<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span> <span class="token operator">=</span>\    lines<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>    te_len <span class="token operator">=</span> int<span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">-</span> int<span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">for</span> te <span class="token keyword">in</span> TEs<span class="token punctuation">:</span>        <span class="token keyword">if</span> te <span class="token keyword">in</span> attributes<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>te<span class="token punctuation">:</span>te_len<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>字典合并的函数：  </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#字典合并的函数，即相同的键的值进行相加</span><span class="token keyword">def</span> <span class="token function">union_dict</span><span class="token punctuation">(</span><span class="token operator">*</span>objs<span class="token punctuation">)</span><span class="token punctuation">:</span>    _keys <span class="token operator">=</span> set<span class="token punctuation">(</span>sum<span class="token punctuation">(</span><span class="token punctuation">[</span>obj<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> obj <span class="token keyword">in</span> objs<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    _total <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> _key <span class="token keyword">in</span> _keys<span class="token punctuation">:</span>        _total<span class="token punctuation">[</span>_key<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>obj<span class="token punctuation">.</span>get<span class="token punctuation">(</span>_key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">for</span> obj <span class="token keyword">in</span> objs<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> _total<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>附上完整代码：  </p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true">#-*- coding: utf-8 -*-</span><span class="token triple-quoted-string string">"""根据REPET输出的GFF3文件统计重复序列的信息"""</span><span class="token keyword">import</span> os<span class="token keyword">from</span> collections <span class="token keyword">import</span> Counter<span class="token comment" spellcheck="true">#使用字典返回TEdenovo的结果</span><span class="token keyword">def</span> <span class="token function">return_TEs</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    TEs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'RYX'</span><span class="token punctuation">,</span> <span class="token string">'RXX-LARD'</span><span class="token punctuation">,</span> <span class="token string">'RIX'</span><span class="token punctuation">,</span> <span class="token string">'RLX'</span><span class="token punctuation">,</span> <span class="token string">'RPX'</span><span class="token punctuation">,</span> <span class="token string">'RSX'</span><span class="token punctuation">,</span> <span class="token string">'RXX-TRIM'</span><span class="token punctuation">,</span> <span class="token string">'DYX'</span><span class="token punctuation">,</span> <span class="token string">'DHX'</span><span class="token punctuation">,</span>    <span class="token string">'DXX-MITE'</span><span class="token punctuation">,</span> <span class="token string">'DMX'</span><span class="token punctuation">,</span> <span class="token string">'DTX'</span><span class="token punctuation">,</span> <span class="token string">'RXX-chim'</span><span class="token punctuation">,</span> <span class="token string">'DXX-chim'</span><span class="token punctuation">,</span> <span class="token string">'noCat'</span><span class="token punctuation">]</span>    <span class="token punctuation">(</span>seqid<span class="token punctuation">,</span> source<span class="token punctuation">,</span> seqtype<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> score<span class="token punctuation">,</span> strand<span class="token punctuation">,</span> phase<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span> <span class="token operator">=</span>\    lines<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>    te_len <span class="token operator">=</span> int<span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">-</span> int<span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">for</span> te <span class="token keyword">in</span> TEs<span class="token punctuation">:</span>        <span class="token keyword">if</span> te <span class="token keyword">in</span> attributes<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>te<span class="token punctuation">:</span>te_len<span class="token punctuation">}</span><span class="token comment" spellcheck="true">#使用字典返回SSR的结果</span><span class="token keyword">def</span> <span class="token function">return_SSRs</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token punctuation">(</span>seqid<span class="token punctuation">,</span> source<span class="token punctuation">,</span> seqtype<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> score<span class="token punctuation">,</span> strand<span class="token punctuation">,</span> phase<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span> <span class="token operator">=</span>\    lines<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>    ssr_len <span class="token operator">=</span> int<span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">-</span> int<span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'SSR'</span><span class="token punctuation">,</span> ssr_len<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#使用字典返回blastx和tblastx的结果</span><span class="token keyword">def</span> <span class="token function">return_Blast</span><span class="token punctuation">(</span>lines<span class="token punctuation">)</span><span class="token punctuation">:</span>    blsat_te<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'TRIM'</span><span class="token punctuation">:</span><span class="token string">'RXX-TRIM'</span><span class="token punctuation">,</span> <span class="token string">'LTR'</span><span class="token punctuation">:</span><span class="token string">'RLX'</span><span class="token punctuation">,</span> <span class="token string">'MITE'</span><span class="token punctuation">:</span><span class="token string">'DXX-MITE'</span><span class="token punctuation">,</span> <span class="token string">'Crypton'</span><span class="token punctuation">:</span><span class="token string">'DYX'</span><span class="token punctuation">,</span>    <span class="token string">'TIR'</span><span class="token punctuation">:</span><span class="token string">'DTX'</span><span class="token punctuation">,</span> <span class="token string">'Helitron'</span><span class="token punctuation">:</span><span class="token string">'DHX'</span><span class="token punctuation">,</span> <span class="token string">'PLE'</span><span class="token punctuation">:</span><span class="token string">'RPX'</span><span class="token punctuation">,</span> <span class="token string">'DIRS'</span><span class="token punctuation">:</span><span class="token string">'RYX'</span><span class="token punctuation">,</span> <span class="token string">'LINE'</span><span class="token punctuation">:</span><span class="token string">'RIX'</span><span class="token punctuation">,</span>    <span class="token string">'SINE'</span><span class="token punctuation">:</span><span class="token string">'RSX'</span><span class="token punctuation">,</span> <span class="token string">'Maverick'</span><span class="token punctuation">:</span><span class="token string">'DMX'</span><span class="token punctuation">,</span> <span class="token string">'ClassI:?'</span><span class="token punctuation">:</span><span class="token string">'RXX-chim'</span><span class="token punctuation">,</span> <span class="token string">'ClassII:?'</span><span class="token punctuation">:</span><span class="token string">'DXX-chim'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#通过字典将REPET中的分类代码与RepBase的分类代码对应起来</span>    <span class="token punctuation">(</span>seqid<span class="token punctuation">,</span> source<span class="token punctuation">,</span> seqtype<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> score<span class="token punctuation">,</span> strand<span class="token punctuation">,</span> phase<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span> <span class="token operator">=</span>\    lines<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>    blast_len <span class="token operator">=</span> int<span class="token punctuation">(</span>end<span class="token punctuation">)</span> <span class="token operator">-</span> int<span class="token punctuation">(</span>start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">for</span> te <span class="token keyword">in</span> blsat_te<span class="token punctuation">:</span>        <span class="token keyword">if</span> te <span class="token keyword">in</span> attributes<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span>blsat_te<span class="token punctuation">[</span>te<span class="token punctuation">]</span><span class="token punctuation">:</span>blast_len<span class="token punctuation">}</span><span class="token comment" spellcheck="true">#字典合并的函数，即相同的键的值进行相加</span><span class="token keyword">def</span> <span class="token function">union_dict</span><span class="token punctuation">(</span><span class="token operator">*</span>objs<span class="token punctuation">)</span><span class="token punctuation">:</span>    _keys <span class="token operator">=</span> set<span class="token punctuation">(</span>sum<span class="token punctuation">(</span><span class="token punctuation">[</span>obj<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">for</span> obj <span class="token keyword">in</span> objs<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    _total <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> _key <span class="token keyword">in</span> _keys<span class="token punctuation">:</span>        _total<span class="token punctuation">[</span>_key<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">(</span><span class="token punctuation">[</span>obj<span class="token punctuation">.</span>get<span class="token punctuation">(</span>_key<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">for</span> obj <span class="token keyword">in</span> objs<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> _totalos<span class="token punctuation">.</span>system<span class="token punctuation">(</span><span class="token string">'cat *.gff3 > genome.gff3'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#合并REPET生成的所有gff3文件</span>te <span class="token operator">=</span> <span class="token string">'REPET_TEs'</span>ssr <span class="token operator">=</span> <span class="token string">'REPET_SSRs'</span>blast <span class="token operator">=</span> <span class="token string">'REPET_blastx'</span>tblast <span class="token operator">=</span> <span class="token string">'REPET_tblastx'</span>genome_size<span class="token operator">=</span><span class="token number">0</span>ssr_num<span class="token punctuation">,</span> ssr_len<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span>TEs<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>TEs_dict<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>Rep<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Rep_dict<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'genome.gff3'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> gff<span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#genome.gff3即前面合并后生成的文件</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> gff<span class="token punctuation">:</span>        <span class="token keyword">if</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'##g'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">pass</span>        <span class="token keyword">elif</span> line<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">'##s'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">,</span> t3<span class="token punctuation">,</span> length<span class="token punctuation">)</span> <span class="token operator">=</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>            genome_size <span class="token operator">+=</span> int<span class="token punctuation">(</span>length<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#计算基因组总长度</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> te <span class="token keyword">in</span> line<span class="token punctuation">:</span>                a <span class="token operator">=</span> return_TEs<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                TEs <span class="token operator">=</span> TEs <span class="token operator">+</span> a<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#种类存入列表</span>                TEs_dict <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>TEs_dict<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#将每一行的结果放入字典</span>            <span class="token keyword">if</span> ssr <span class="token keyword">in</span> line<span class="token punctuation">:</span>                b <span class="token operator">=</span> return_SSRs<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                ssr_num <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true">#计算SSR的个数</span>                ssr_len <span class="token operator">+=</span> b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">#计算SSR的总长度</span>            <span class="token keyword">if</span> blast <span class="token keyword">in</span> line <span class="token operator">or</span> tblast <span class="token keyword">in</span> line<span class="token punctuation">:</span>                c <span class="token operator">=</span> return_Blast<span class="token punctuation">(</span>line<span class="token punctuation">)</span>                Rep <span class="token operator">=</span> Rep <span class="token operator">+</span> c<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>                Rep_dict <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>Rep_dict<span class="token punctuation">,</span> c<span class="token punctuation">)</span>zero<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'RYX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RXX-LARD'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RIX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RLX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RPX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RSX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RXX-TRIM'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DYX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DHX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token string">'DXX-MITE'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DMX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DTX'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'noCat'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'RXX-chim'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'DXX-chim'</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">#创建一个包含所有类型代码的字典，然后将之前的结果与其相加，避免空值</span>TEs_type <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>dict<span class="token punctuation">(</span>Counter<span class="token punctuation">(</span>TEs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> zero<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 列表里的重复值唯一化，并计算重复的次数（相当于每种类型的个数)</span>Rep_type <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>dict<span class="token punctuation">(</span>Counter<span class="token punctuation">(</span>Rep<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> zero<span class="token punctuation">)</span>TEs_dict <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>TEs_dict<span class="token punctuation">,</span> zero<span class="token punctuation">)</span>Rep_dict <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>Rep_dict<span class="token punctuation">,</span> zero<span class="token punctuation">)</span>all_type <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>TEs_type<span class="token punctuation">,</span> Rep_type<span class="token punctuation">,</span> zero<span class="token punctuation">)</span>all_len <span class="token operator">=</span> union_dict<span class="token punctuation">(</span>TEs_dict<span class="token punctuation">,</span> Rep_dict<span class="token punctuation">,</span> zero<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bioinformatics </tag>
            
            <tag> gff </tag>
            
            <tag> gene </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyclone安装测试</title>
      <link href="/2018/03/25/Pyclone%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/03/25/Pyclone%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>PyClone is statistical model and software tool designed to infer the prevalence of point mutations in heterogeneous cancer samples. The input data for PyClone consists of a set read counts from a deep sequencing experiment, the copy number of the genomic region containing the mutation and an estimate of tumour content.</p><p>Pyclone基于的是MCMC算法.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方推荐使用conda来安装PyClone.为了保证环境的稳定，可为PyClone单独建立一个环境，因为PyClone基于Python2.7:</p><pre class="line-numbers language-bash"><code class="language-bash">conda create --name pyclone python<span class="token operator">=</span>2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>激活环境：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> activate pyclone<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出环境：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">source</span> deactivate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装PyClone：</p><pre class="line-numbers language-bash"><code class="language-bash">conda <span class="token function">install</span> pyclone -c aroth85<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="分析命令："><a href="#分析命令：" class="headerlink" title="分析命令："></a>分析命令：</h3><pre class="line-numbers language-bash"><code class="language-bash">PyClone run_analysis_pipeline --in_files A.tsv B.tsv C.tsv --working_dir pyclone_analysis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>PyClone可以分析来自同一个病人的不同样本</p><h3 id="输入文件："><a href="#输入文件：" class="headerlink" title="输入文件："></a>输入文件：</h3><p>输入文件为tsv文件，具体格式如下</p><pre class="line-numbers language-tsv"><code class="language-tsv">mutation_id    ref_counts    var_counts    normal_cn    minor_cn    major_cn    variant_case    variant_freq    genotypeNA12156:BB:chr2:175263063    3812    14    2    0    2    NA12156    0.0036591740721380033    BBNA12156:BB:chr1:46500613    3933    42    2    0    2    NA12156    0.010566037735849057    BBNA12156:BB:chr19:43763059    10352    42    2    0    2    NA12156    0.004040792765056763    BBNA18507:BB:chr5:180166866    2786    1058    2    0    2    NA18507    0.27523413111342354    BBNA12878:BB:chr10:17875816    3134    190    2    0    2    NA12878    0.057160048134777375    BB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各列说明如下:</p><ul><li><p>mutation_id - A unique ID to identify the mutation. Good names are thing such a the genomic co-ordinates of the mutation i.e. chr22:12345. Gene names are not good IDs because one gene may have multiple mutations, in which case the ID is not unique and PyClone will fail to run or worse give unexpected results. If you want to include the gene name I suggest adding the genomic coordinates i.e. TP53_chr17:753342.</p></li><li><p>ref_counts - The number of reads covering the mutation which contain the reference (genome) allele.</p></li><li><p>var_counts - The number of reads covering the mutation which contain the variant allele.</p></li><li><p>normal_cn - The copy number of the cells in the normal population. For autosomal chromosomes this will be 2 and for sex chromosomes it could be either 1 or 2. For species besides human other values are possible.</p></li><li><p>minor_cn - The minor copy number of the cancer cells. Usually this value will be predicted from WGSS or array data.</p></li><li><p>major_cn - The major copy number of the cancer cells. Usually this value will be predicted from WGSS or array data.</p></li></ul><blockquote><p>If you do not major and minor copy number information you should set the minor copy number to 0, and the major copy number to the predicted total copy number. If you do this make sure to use the total_copy_number for the –prior flag of the build_mutations_file, setup_analysis and run_analysis_pipeline commands. DO NOT use the parental copy number or major_copy_number information method as it assumes you have knowledge of the minor and major copy number.</p></blockquote><blockquote><p>Any additional columns in the tsv file will be ignored so feel free to add additional annotation fields.</p></blockquote><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>输出文件夹内包含1个配置文件和3个文件夹，分别如下：</p><ul><li><p>config.yaml - This file specifies the configuration used for the PyClone analysis.</p></li><li><p>plots - Contains all plots from the analysis. There will be two sub-folders clusters/ and loci/ for cluster and locus specific plots respectively.</p></li><li><p>tables - This contains the output tables with summarized results for the analysis. There will be two tables clusters.tsv and loci.tsv, for cluster and locus specific information.</p></li><li><p>trace - This the raw trace from the MCMC sampling algorithm. Advanced users may wish to work with these files directly for generating plots and summary statistics.</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>因为PyClone调用了matplotlib来作图，由于集群的原因，直接跑PyClone的命令，最后会报一个关于agg的错误。</p><p>解决方法是修改Pyclone包里<code>PathOfPyclone/pyclone/post_process/clusters.py</code>的文件，在最上方的注释下面一行加入：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> matplotlibmatplotlib<span class="token punctuation">.</span>use<span class="token punctuation">(</span><span class="token string">'agg'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pyclone </tag>
            
            <tag> tumor </tag>
            
            <tag> bioinformatics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PureCN测试</title>
      <link href="/2018/02/23/PureCN%E6%B5%8B%E8%AF%95/"/>
      <url>/2018/02/23/PureCN%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="PureCN测试"><a href="#PureCN测试" class="headerlink" title="PureCN测试"></a>PureCN测试</h1><h2 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h2><pre class="line-numbers language-bash"><code class="language-bash">R version 3.4.3 <span class="token punctuation">(</span>2017-11-30<span class="token punctuation">)</span>Platform: x86_64-pc-linux-gnu <span class="token punctuation">(</span>64-bit<span class="token punctuation">)</span>Running under: CentOS release 6.5 <span class="token punctuation">(</span>Final<span class="token punctuation">)</span>Matrix products: defaultBLAS: /p299/user/og06/chenxiangjian1609/software/R/lib64/R/lib/libRblas.soLAPACK: /p299/user/og06/chenxiangjian1609/software/R/lib64/R/lib/libRlapack.soR_path: /p299/user/og06/chenxiangjian1609/software/R/bin/RRscript_path: /p299/user/og06/chenxiangjian1609/software/R/bin/RscriptPureCN.R_path: /p299/user/og06/chenxiangjian1609/software/miniconda3/lib/R/library/PureCN/测试路径： /p299/user/og06/chenxiangjian1609/dev/cnv/test2/pure/test_1206/third<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="输入文件"><a href="#输入文件" class="headerlink" title="输入文件"></a>输入文件</h2><ul><li>reference.fa: 基因组文件</li><li>panel9b.bed： 捕获区域panel文件</li><li>OG165910035T1CFD20kx9b1_mutect.vcf： Mutect软件生成的VCF文件</li><li>OG165910035T1CFD20kx9b1.csv： CNVkit生成的cns文件转换成SNP6格式的文件。即6列，分别是Sample，chrom，start，end，probes，log2(seg_mean)</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="step1-Generate-an-interval-file-from-a-BED-file-containing-target-coordinates"><a href="#step1-Generate-an-interval-file-from-a-BED-file-containing-target-coordinates" class="headerlink" title="step1 Generate an interval file from a BED file containing target coordinates"></a>step1 Generate an interval file from a BED file containing target coordinates</h3><pre class="line-numbers language-bash"><code class="language-bash">/p299/user/og06/chenxiangjian1609/software/R/bin/Rscript \/p299/user/og06/chenxiangjian1609/software/miniconda3/lib/R/library/PureCN/extdata/IntervalFile.R \--infile panel9b.bed --fasta reference.fa --outfile baits_hg19_gcgene2.txt --genome hg19 --offtarget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>生成的<strong>baits_hg19_gcgene2.txt</strong>用于下一步</p><h3 id="step2-determine-purity-and-ploidy"><a href="#step2-determine-purity-and-ploidy" class="headerlink" title="step2 determine purity and ploidy"></a>step2 determine purity and ploidy</h3><pre class="line-numbers language-bash"><code class="language-bash">/p299/user/og06/chenxiangjian1609/software/R/bin/Rscript \/p299/user/og06/chenxiangjian1609/software/miniconda3/lib/R/library/PureCN/extdata/PureCN.R \--out result2 --sampleid OG165910035T1CFD20kx9b1 --segfile OG165910035T1CFD20kx9b1.csv --vcf \OG165910035T1CFD20kx9b1_mutect.vcf --genome hg19 --gcgene baits_hg19_gcgene2.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>生成的结果文件如下：</p><pre class="line-numbers language-bash"><code class="language-bash">result2_segmentation.pdfresult2.rdsresult2.logresult2.csvresult2.pdf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在csv结果文件中可见tumor样本的纯度和倍性，如下表所示</p><table><thead><tr><th>Sampleid</th><th>Purity</th><th>Ploidy</th><th>Sex</th><th>Contamination</th><th>Flagged</th><th>Failed</th><th>Curated</th><th>Comment</th></tr></thead><tbody><tr><td>OG165910035T1CFD20kx9b1</td><td>0.22</td><td>1.336</td><td>？</td><td>0</td><td>TRUE</td><td>FALSE</td><td>FALSE</td><td>RARE KARYOTYPE;LOW PURITY</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 生信 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tumor </tag>
            
            <tag> bioinformatics </tag>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>argparse包使用</title>
      <link href="/2018/02/20/argparse%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/02/20/argparse%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Argparse简介"><a href="#Argparse简介" class="headerlink" title="Argparse简介"></a>Argparse简介</h2><p>argparse是python自带的一个命令行解析包，非常适合编写可读性好的命令行程序。<br>要使用的话，直接导入即可，无需另外安装。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>新建一个 <code>parse.py</code>文件如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># !/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> argparse<span class="token comment" spellcheck="true"># get parameters</span><span class="token keyword">def</span> <span class="token function">parse_args</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    description <span class="token operator">=</span> u<span class="token string">"扫描给定项目路径，生成路径下数据信息"</span>    parse <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span>description<span class="token operator">=</span>description<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"输出文件名称"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'output'</span><span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"已记录好的总表，如不存在可用'-'代替"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'backup'</span><span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"需要扫描的项目目录,可输入多个"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'filepath'</span><span class="token punctuation">,</span> nargs<span class="token operator">=</span><span class="token string">'*'</span><span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"项目名称"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-p'</span><span class="token punctuation">,</span><span class="token string">'--project'</span><span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"数据类型, 默认值为: FASTQ"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-t'</span><span class="token punctuation">,</span><span class="token string">'--type'</span><span class="token punctuation">,</span>default<span class="token operator">=</span><span class="token string">'FASTQ'</span> <span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"测序平台, 默认值为: Illumina"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-c'</span><span class="token punctuation">,</span> <span class="token string">'--cexu'</span><span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token string">'Illumina'</span><span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    help <span class="token operator">=</span> u<span class="token string">"文库大小, 数据类型:int(整数型)"</span>    parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-l'</span><span class="token punctuation">,</span> <span class="token string">'--library'</span><span class="token punctuation">,</span>  type<span class="token operator">=</span>int<span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>    args <span class="token operator">=</span> parse<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> args<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    args <span class="token operator">=</span> parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span>    output <span class="token operator">=</span> args<span class="token punctuation">.</span>output    backup <span class="token operator">=</span> args<span class="token punctuation">.</span>backup    filepath <span class="token operator">=</span> args<span class="token punctuation">.</span>filepath    project <span class="token operator">=</span> args<span class="token punctuation">.</span>project    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行 <code>python parse.py -h</code> </p><pre class="line-numbers language-bash"><code class="language-bash">usage: scanData.py <span class="token punctuation">[</span>-h<span class="token punctuation">]</span> <span class="token punctuation">[</span>-p PROJECT<span class="token punctuation">]</span> <span class="token punctuation">[</span>-t TYPE<span class="token punctuation">]</span> <span class="token punctuation">[</span>-c CEXU<span class="token punctuation">]</span> <span class="token punctuation">[</span>-l LIBRARY<span class="token punctuation">]</span>                   output backup <span class="token punctuation">[</span>filepath <span class="token punctuation">[</span>filepath <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>扫描给定项目路径，生成路径下数据信息positional arguments:  output                输出文件名称  backup                已记录好的总表，如不存在可用<span class="token string">'-'</span>代替  filepath              需要扫描的项目目录,可输入多个optional arguments:  -h, --help            show this <span class="token function">help</span> message and <span class="token keyword">exit</span>  -p PROJECT, --project PROJECT                        项目名称  -t TYPE, --type TYPE  数据类型, 默认值为: FASTQ  -c CEXU, --cexu CEXU  测序平台, 默认值为: Illumina  -l LIBRARY, --library LIBRARY                        文库大小, 数据类型:int<span class="token punctuation">(</span>整数型<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到帮助信息是由argparse包自动生成的。且帮助信息是可以自己定义的。</p><h2 id="定位参数"><a href="#定位参数" class="headerlink" title="定位参数"></a>定位参数</h2><p>在上述程序中，<code>output</code>, <code>backup</code>, <code>filpath</code>这3个参数在帮助信息中是<code>positional arguments</code>，中文意思就是<code>定位参数</code>，用法是不用带<code>-</code>就能使用。顾名思义，这些参数的位置是固定的，前后顺序是无法更换的，且这些参数是必选的，不全的话就会报错。</p><pre class="line-numbers language-bash"><code class="language-bash">python scanData.py test.txtusage: scanData.py <span class="token punctuation">[</span>-h<span class="token punctuation">]</span> <span class="token punctuation">[</span>-p PROJECT<span class="token punctuation">]</span> <span class="token punctuation">[</span>-t TYPE<span class="token punctuation">]</span> <span class="token punctuation">[</span>-c CEXU<span class="token punctuation">]</span> <span class="token punctuation">[</span>-l LIBRARY<span class="token punctuation">]</span>                   output backup <span class="token punctuation">[</span>filepath <span class="token punctuation">[</span>filepath <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>scanData.py: error: too few arguments<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>上述程序中的其他参数，在帮助信息中显示是<code>optional arguments</code>， 意思是可选参数。可以使用<code>-</code>来指定短参数，也可以使用<code>--</code>来表示长参数。可选参数是<code>非必选</code>的，可用可不用。而且顺序是可以随意更换的。</p><h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>在<code>argparse</code>中可以对参数的<code>数据类型、默认值、可选值、帮助信息</code>等进行设置。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># !/usr/bin/python</span><span class="token comment" spellcheck="true"># -*- coding: UTF-8 -*-</span><span class="token keyword">import</span> argparseparse <span class="token operator">=</span> argparse<span class="token punctuation">.</span>ArgumentParser<span class="token punctuation">(</span><span class="token punctuation">)</span>help <span class="token operator">=</span> u<span class="token string">"文库大小, 数据类型:int(整数型)"</span>parse<span class="token punctuation">.</span>add_argument<span class="token punctuation">(</span><span class="token string">'-l'</span><span class="token punctuation">,</span> <span class="token string">'--library'</span><span class="token punctuation">,</span>  type<span class="token operator">=</span>int<span class="token punctuation">,</span> default<span class="token operator">=</span><span class="token number">150</span><span class="token punctuation">,</span> choice<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">150</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">,</span> help<span class="token operator">=</span>help<span class="token punctuation">)</span>args <span class="token operator">=</span> parse<span class="token punctuation">.</span>parse_args<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>add_argument</code>方法中，<code>type</code>指定数据类型，<code>default</code>指定默认值，<code>choice</code>指定可选值， <code>help</code>指定自定义帮助信息。<code>nargs</code>可以指定参数的数量，值可以为正整数，也可以为<code>*</code>表示<code>任意个数，可以为0个</code>， 还可以为<code>+</code>，代表<code>1或1以上的个数</code>。</p><p>在上述的<code>parse.py</code>中，<code>filepath</code>这个参数的个数就是不固定的，可以传入多个参数。参数解析之后，得到的是一个数组。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">Argparse文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> argparse </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
